<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prototype Viewer - ÎûúÎìúÎßàÌÅ¨ vs ÏõπÏ∫† ÎπÑÍµê</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            height: 100vh;
            overflow: hidden;
        }
        .header {
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            padding: 15px 30px;
            color: #333;
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
        }
        .header-content {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 30px;
        }
        .header-title {
            flex-shrink: 0;
        }
        .header-title h1 {
            font-size: 24px;
            font-weight: 300;
            margin-bottom: 5px;
            color: #2c3e50;
        }
        .header-title p {
            font-size: 14px;
            opacity: 0.7;
            color: #34495e;
            margin: 0;
        }
        .header-controls {
            display: flex;
            align-items: center;
            gap: 20px;
            flex-wrap: wrap;
        }
        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .control-group label {
            color: #2c3e50;
            font-size: 12px;
            font-weight: 500;
            white-space: nowrap;
        }
        .control-buttons {
            display: flex;
            gap: 5px;
        }
        .control-buttons button {
            padding: 6px 12px;
            font-size: 11px;
        }
        .control-toggles {
            display: flex;
            gap: 15px;
        }
        .control-toggles label {
            color: #2c3e50;
            font-size: 12px;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .main-container {
            display: flex;
            height: calc(100vh - 80px);
        }
        .left-panel, .right-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            position: relative;
        }
        .left-panel {
            background: rgba(255, 255, 255, 0.95);
            border-right: 2px solid rgba(0, 0, 0, 0.1);
        }
        .right-panel {
            background: rgba(255, 255, 255, 0.95);
        }
        .panel-title {
            background: rgba(52, 73, 94, 0.9);
            color: white;
            padding: 10px 20px;
            font-size: 16px;
            font-weight: 500;
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
        }
        .controls {
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
        }
        .control-row {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 10px;
        }
        .control-row:last-child { margin-bottom: 0; }
        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .control-group label {
            color: #2c3e50;
            font-size: 12px;
            min-width: 60px;
            font-weight: 500;
        }
        select, input[type="range"] {
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid rgba(0, 0, 0, 0.2);
            color: #2c3e50;
            padding: 5px 8px;
            border-radius: 4px;
            font-size: 12px;
        }
        select option {
            background: #fff;
            color: #2c3e50;
        }
        button {
            background: linear-gradient(45deg, #3498db, #2980b9);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s ease;
        }
        button:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.3);
        }
        button:active {
            transform: translateY(0);
        }
        .canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            background: #f8f9fa;
        }
        #landmark-canvas, #webcam-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        .webcam-container {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #f8f9fa;
            position: relative;
        }
        #webcam-video {
            max-width: 100%;
            max-height: 100%;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }
        #webcam-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            border-radius: 8px;
        }
        .webcam-overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.9);
            color: #2c3e50;
            padding: 10px 15px;
            border-radius: 6px;
            font-size: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        .status-indicator {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #e74c3c;
        }
        .status-indicator.active {
            background: #27ae60;
            box-shadow: 0 0 10px #27ae60;
        }
        .info-text {
            color: #7f8c8d;
            font-size: 11px;
            margin-top: 5px;
        }
        .legend {
            display: flex;
            gap: 15px;
            margin-top: 10px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
            color: #2c3e50;
            font-size: 11px;
        }
        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="header-content">
            <div class="header-title">
                <h1>Prototype Viewer</h1>
                <p>ÎûúÎìúÎßàÌÅ¨ Ïï†ÎãàÎ©îÏù¥ÏÖò vs Ïã§ÏãúÍ∞Ñ ÏõπÏ∫† ÎπÑÍµê</p>
            </div>
            <div class="header-controls">
                <div class="control-group">
    <label>Ìè¨Ï¶à X:</label>
    <input type="number" id="pose-x" value="0" step="0.001" style="width: 60px;" oninput="updatePoseOffset('x', this.value)">
</div>
<div class="control-group">
    <label>Ìè¨Ï¶à Y:</label>
    <input type="number" id="pose-y" value="0" step="0.001" style="width: 60px;" oninput="updatePoseOffset('y', this.value)">
</div>
<div class="control-group">
    <label>Ìè¨Ï¶à Z:</label>
    <input type="number" id="pose-z" value="-0.3" step="0.001" style="width: 60px;" oninput="updatePoseOffset('z', this.value)">
</div>
<div class="control-group">
    <label>Ìè¨Ï¶à ÌÅ¨Í∏∞:</label>
    <input type="number" id="pose-scale" value="0.8" step="0.001" style="width: 60px;" oninput="updatePoseScale(this.value)">
</div>
                <div class="control-group">
                    <label>ÎπÑÎîîÏò§:</label>
                    <select id="video-select"></select>
                </div>
                <div class="control-group">
                    <label>ÌîÑÎ†àÏûÑ:</label>
                    <span id="current-frame">0</span>
                </div>
                <div class="control-buttons">
                    <button onclick="previousFrame()">‚óÄ</button>
                    <button onclick="playAnimation()" id="play-btn">‚ñ∂</button>
                    <button onclick="nextFrame()">‚ñ∂</button>
                    <button onclick="resetCamera()">üîÑ</button>
                </div>
                <div class="control-group">
                    <label>ÌîÑÎ†àÏûÑ:</label>
                    <input type="range" id="frame-slider" min="0" max="0" value="0" style="width: 120px;" oninput="sliderFrame(this.value)">
                </div>
                <div class="control-group">
                    <label>ÏÜçÎèÑ:</label>
                    <input type="range" id="speed" min="1" max="30" value="5" onchange="updateSpeed()" style="width: 80px;">
                    <span id="speed-value">5</span>
                </div>
                <div class="control-toggles">
                    <label><input type="checkbox" id="show-cylinders" checked> ÏõêÍ∏∞Îë•(ÏÑ†)</label>
                    <label><input type="checkbox" id="show-left-hand" checked> Ï¢åÏ∏° ÏÜê</label>
                    <label><input type="checkbox" id="show-right-hand" checked> Ïö∞Ï∏° ÏÜê</label>
                </div>
            </div>
        </div>
    </div>
    
    <div class="main-container">
        <!-- Ï¢åÏ∏° Ìå®ÎÑê: ÎûúÎìúÎßàÌÅ¨ Î∑∞Ïñ¥ (Ï†ÑÏ≤¥ Í≥µÍ∞Ñ) -->
        <div class="left-panel">
            <div class="panel-title">3D ÎûúÎìúÎßàÌÅ¨ Î∑∞Ïñ¥</div>
            <div class="canvas-container">
                <canvas id="landmark-canvas"></canvas>
            </div>
        </div>
        
        <!-- Ïö∞Ï∏° Ìå®ÎÑê: ÏõπÏ∫† + Ïª®Ìä∏Î°§ -->
        <div class="right-panel">
            <div class="panel-title">Ïã§ÏãúÍ∞Ñ ÏõπÏ∫†</div>
            
            <div class="webcam-container">
                <video id="webcam-video" autoplay muted playsinline></video>
                <canvas id="webcam-overlay" style="position: absolute; top: 0; left: 0; pointer-events: none;"></canvas>
                <div class="webcam-overlay">
                    <div>ÏõπÏ∫† Ïä§Ìä∏Î¶º</div>
                    <div id="webcam-status">Ïó∞Í≤∞ Ï§ë...</div>
                </div>
                <div class="status-indicator" id="webcam-indicator"></div>
            </div>
        </div>
    </div>

    <script>
        // ÎûúÎìúÎßàÌÅ¨ Î∑∞Ïñ¥ Í¥ÄÎ†® Î≥ÄÏàòÎì§
        let scene, camera, renderer;
        let poseObjects = [], leftHandObjects = [], rightHandObjects = [];
        let poseLines = [], leftHandLines = [], rightHandLines = [];
        let currentFrame = 0;
        let isPlaying = false;
        let animationSpeed = 30;
        let animationInterval;
        let allData = null;
        let data = null;
        
        // Ïπ¥Î©îÎùº Ïª®Ìä∏Î°§ Î≥ÄÏàò (ÌîåÎùºÏù¥/ÌîÑÎ¶¨ Î¨¥Î∏å)
        // Ï¥àÍ∏∞ Ïπ¥Î©îÎùº ÏÑ§Ï†ï:
        // - ÏúÑÏπò: (-0.388, 0.334, -0.655) - ÏÇ¨Ïö©Ïûê ÏßÄÏ†ï ÏúÑÏπò
        // - Yaw: -10.3ÎèÑ (Ï¢åÏö∞ ÌöåÏ†Ñ) - ÏÇ¨Ïö©Ïûê ÏßÄÏ†ï Í∞ÅÎèÑ
        // - Pitch: 178.7ÎèÑ (ÏÉÅÌïò ÌöåÏ†Ñ) - ÏÇ¨Ïö©Ïûê ÏßÄÏ†ï Í∞ÅÎèÑ
        // - Roll: 0ÎèÑ (ÏãúÏ†ê ÌöåÏ†Ñ) - ÏÇ¨Ïö©Ïûê ÏßÄÏ†ï Í∞ÅÎèÑ
        let cameraInitPos = { x: 0.453, y: 0.489, z: 0.592 };
        let cameraInitRot = { x: 0, y: 0, z: 0 };
        let isMouseDown = false;
        let lastMouseX = 0, lastMouseY = 0;
        let yaw = 0;
        let pitch = 0;
        let roll = 0;
        // ÎûúÎìúÎßàÌÅ¨ Î∑∞Ïñ¥ Í¥ÄÎ†® Î≥ÄÏàòÎì§ Î∂ÄÎ∂ÑÏóê Ï∂îÍ∞Ä
let poseScale = 0.8;  // Ìè¨Ï¶à ÌÅ¨Í∏∞ Ï°∞Ï†à
let poseOffset = { x: -0.090, y: 0.098, z: -0.934 };  // Ìè¨Ï¶à ÏúÑÏπò Ï°∞Ï†à (-0.3 + -0.634 = -0.934)


        // ÏÉâÏÉÅ
        const POSE_COLOR = 0x00b894;
        const LEFT_COLOR = 0xF4A258;
        const RIGHT_COLOR = 0x5fa5fb;
        
        // Ïó∞Í≤∞ Íµ¨Ï°∞
        // Ìè¨Ï¶à Ïö∞Ï∏° ÏÜê [15,17],[15,19],[15,21],[17,19]
        // Ìè¨Ï¶à Ï¢åÏ∏° ÏÜê [16,18],[16,20],[16,22],[18,20]

        // ÏñºÍµ¥  [0,1],[1,2],[2,3],[3,7],[0,4],[4,5],[5,6],[6,8],
        const POSE_CONNECTIONS = [
           [9,10],[11,12],[11,13],[13,15],[12,14],[14,16],[11,23],[12,24]
        ];
        const HAND_CONNECTIONS = [
            [0,1],[1,2],[2,3],[3,4],
            [0,5],[5,6],[6,7],[7,8],
            [0,9],[9,10],[10,11],[11,12],
            [0,13],[13,14],[14,15],[15,16],
            [0,17],[17,18],[18,19],[19,20],
            [5,9],[9,13],[13,17],[5,17]
        ];
        
        // ÏõπÏ∫† Í¥ÄÎ†® Î≥ÄÏàò
        let webcamStream = null;
        let webcamVideo = null;
        
        // Ï¥àÍ∏∞Ìôî
        window.onload = function() {
            // Ï¥àÍ∏∞ Ìè¨Ï¶à Ïò§ÌîÑÏÖã Í∞í ÏÑ§Ï†ï
            document.getElementById('pose-x').value = poseOffset.x.toFixed(3);
            document.getElementById('pose-y').value = poseOffset.y.toFixed(3);
            document.getElementById('pose-z').value = poseOffset.z.toFixed(3);
            document.getElementById('pose-scale').value = poseScale.toFixed(3);
            
            initLandmarkViewer();
        };
        
        // Ïó∞Í≤∞ Íµ¨Ï°∞ Ï†ïÏùò ÏïÑÎûòÏóê Ï∂îÍ∞Ä
// ÎûúÎìúÎßàÌÅ¨ ÌöåÏ†Ñ Î∞è Ï°∞Ï†ï Ìï®Ïàò
function rotateLandmark(landmark, isBody = false) {
    // Í∏∞Î≥∏ ÌöåÏ†Ñ (xÏôÄ z Ï¢åÌëú Î∞òÏ†Ñ)
    let result = [-landmark[0], landmark[1], -landmark[2]];
    
    // Ìè¨Ï¶à(Ïã†Ï≤¥)Ïù∏ Í≤ΩÏö∞ÏóêÎßå Ïä§ÏºÄÏùº Î∞è Ïò§ÌîÑÏÖã Ï†ÅÏö©
    if (isBody) {
        result[0] = result[0] * poseScale + poseOffset.x;
        result[1] = result[1] * poseScale + poseOffset.y;
        result[2] = result[2] * poseScale + poseOffset.z;
    }
    
    return result;
}

        // ÎûúÎìúÎßàÌÅ¨ Î∑∞Ïñ¥ Ï¥àÍ∏∞Ìôî
        function initLandmarkViewer() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xdbdbdb);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / 2 / window.innerHeight, 0.001, 1000);
            camera.position.set(cameraInitPos.x, cameraInitPos.y, cameraInitPos.z);
            camera.rotation.set(cameraInitRot.x, cameraInitRot.y, cameraInitRot.z);

            yaw = -186.2 * Math.PI / 180;
            pitch = 192.5 * Math.PI / 180;
            roll = 0 * Math.PI / 180;
            // yaw = -10.3 * Math.PI / 180;
            // pitch = 178.7 * Math.PI / 180;
            // roll = 0 * Math.PI / 180;

            updateCameraDirection();
            
            const canvas = document.getElementById('landmark-canvas');
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true, alpha: true });
            renderer.setSize(canvas.offsetWidth, canvas.offsetHeight);
            renderer.setClearColor(0xf8f9fa, 1);


            
            const ambientLight = new THREE.AmbientLight(0x404040, 0.8);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);
            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight2.position.set(-1, 1, -1);
            scene.add(directionalLight2);

            // Ï¢åÏö∞Î∞òÏ†Ñ Ï†ÅÏö©
            const mirrorMatrix = new THREE.Matrix4().makeScale(-1, 1, 1);
            scene.applyMatrix4(mirrorMatrix);
            
            // Îç∞Ïù¥ÌÑ∞ Î°úÎìú
            loadLandmarkData();
            
            // Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà
            setupEventListeners();
            
            animate();
            
            // Ï¥àÍ∏∞ Ïπ¥Î©îÎùº ÏÉÅÌÉú Î°úÍ∑∏
            logCameraState('Ï¥àÍ∏∞Ìôî');
        }
     
        
        // MediaPipe Tasks Vision Ï¥àÍ∏∞Ìôî
        let handLandmarker = null;
        let webcamOverlay = null;
        let webcamCtx = null;
        
     
        
        function drawHandLandmarks(landmarks, color) {
            // ÏÜê Ïó∞Í≤∞ÏÑ† Ï†ïÏùò
            const HAND_CONNECTIONS = [
                [0,1],[1,2],[2,3],[3,4],
                [0,5],[5,6],[6,7],[7,8],
                [0,9],[9,10],[10,11],[11,12],
                [0,13],[13,14],[14,15],[15,16],
                [0,17],[17,18],[18,19],[19,20],
                [5,9],[9,13],[13,17],[5,17]
            ];
            
            // Ïó∞Í≤∞ÏÑ† Í∑∏Î¶¨Í∏∞
            HAND_CONNECTIONS.forEach(([start, end]) => {
                const startPoint = landmarks[start];
                const endPoint = landmarks[end];
                
                if (startPoint && endPoint) {
                    const startX = startPoint.x * webcamOverlay.width;
                    const startY = startPoint.y * webcamOverlay.height;
                    const endX = endPoint.x * webcamOverlay.width;
                    const endY = endPoint.y * webcamOverlay.height;
                    
                    webcamCtx.strokeStyle = color;
                    webcamCtx.lineWidth = 2;
                    webcamCtx.beginPath();
                    webcamCtx.moveTo(startX, startY);
                    webcamCtx.lineTo(endX, endY);
                    webcamCtx.stroke();
                }
            });
            
            // ÎûúÎìúÎßàÌÅ¨ Ï†ê Í∑∏Î¶¨Í∏∞
            landmarks.forEach(landmark => {
                const x = landmark.x * webcamOverlay.width;
                const y = landmark.y * webcamOverlay.height;
                
                webcamCtx.fillStyle = color;
                webcamCtx.beginPath();
                webcamCtx.arc(x, y, 3, 0, 2 * Math.PI);
                webcamCtx.fill();
            });
        }
        
        // ÎûúÎìúÎßàÌÅ¨ Îç∞Ïù¥ÌÑ∞ Î°úÎìú
        function loadLandmarkData() {
            // file_list.jsonÏóêÏÑú ÌååÏùº Î™©Î°ù Î°úÎìú
            fetch('file_list.json')
                .then(response => {
                    if (!response.ok) {
                        throw new Error('file_list.json Î°úÎìú Ïã§Ìå®');
                    }
                    return response.json();
                })
                .then(fileList => {
                    const jsonFiles = fileList.landmark_files || [];
                    console.log('ÌååÏùº Î™©Î°ùÏóêÏÑú Î∞úÍ≤¨Îêú ÌååÏùºÎì§:', jsonFiles);
                    
                    if (jsonFiles.length === 0) {
                        throw new Error('file_list.jsonÏóê ÌååÏùºÏù¥ ÏóÜÏäµÎãàÎã§.');
                    }
                    
                    // Í∞Å ÌååÏùºÏùÑ Î°úÎìú
                    const loadPromises = jsonFiles.map(filename => 
                        fetch(`result/${filename}`)
                            .then(response => {
                                if (!response.ok) {
                                    throw new Error(`HTTP ${response.status}`);
                                }
                                return response.json();
                            })
                            .then(data => ({ filename, data }))
                            .catch(error => {
                                console.warn(`ÌååÏùº Î°úÎìú Ïã§Ìå®: ${filename} - ${error.message}`);
                                return null;
                            })
                    );
                    
                    return Promise.all(loadPromises);
                })
                .then(results => {
                    const validResults = results.filter(result => result !== null);
                    
                    if (validResults.length === 0) {
                        throw new Error('Î°úÎìú Í∞ÄÎä•Ìïú JSON ÌååÏùºÏù¥ ÏóÜÏäµÎãàÎã§.');
                    }
                    
                    console.log('ÏÑ±Í≥µÏ†ÅÏúºÎ°ú Î°úÎìúÎêú ÌååÏùºÎì§:', validResults.map(r => r.filename));
                    return validResults;
                })
                .then(results => {
                    // allDataÎ•º ÌååÏùºÎ™ÖÏùÑ ÌÇ§Î°ú ÌïòÎäî Í∞ùÏ≤¥Î°ú Íµ¨ÏÑ±
                    allData = {};
                    results.forEach(({ filename, data }) => {
                        const baseName = filename.replace('_landmarks.json', '');
                        allData[baseName] = data;
                    });
                    
                    const select = document.getElementById('video-select');
                    
                    // ÌååÏùº ÏÑ†ÌÉù ÏòµÏÖò ÏÉùÏÑ±
                    Object.keys(allData).forEach(filename => {
                        const opt = document.createElement('option');
                        opt.value = filename;
                        opt.textContent = filename;
                        select.appendChild(opt);
                    });
                    
                    select.onchange = function() {
                        data = allData[select.value];
                        document.getElementById('frame-slider').max = data.pose.length - 1;
                        loadFrame(0);
                    };
                    
                    select.value = Object.keys(allData)[0];
                    select.onchange();
                })
                .catch(error => {
                    console.error('Îç∞Ïù¥ÌÑ∞ Î°úÎìú Ïã§Ìå®:', error);
                    document.querySelector('.left-panel').innerHTML = `
                        <div style="color: white; padding: 20px; text-align: center;">
                            <h3>Îç∞Ïù¥ÌÑ∞ Î°úÎìú Ïã§Ìå®</h3>
                            <p>${error.message}</p>
                            <p>result ÎîîÎ†âÌÜ†Î¶¨Ïóê JSON ÌååÏùºÏù¥ ÏûàÎäîÏßÄ ÌôïÏù∏Ìï¥Ï£ºÏÑ∏Ïöî.</p>
                        </div>
                    `;
                });
        }
        
        // Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà ÏÑ§Ï†ï
        function setupEventListeners() {
            // ÌÇ§Î≥¥Îìú Ïª®Ìä∏Î°§ (ÏãúÏ†ê Ïù¥Îèô ÌôúÏÑ±Ìôî)
            document.addEventListener('keydown', handleKeyDown);
            
            // ÎßàÏö∞Ïä§ Ïª®Ìä∏Î°§ (ÏãúÏ†ê Ïù¥Îèô ÌôúÏÑ±Ìôî)
            const canvas = document.getElementById('landmark-canvas');
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('mouseleave', handleMouseUp);
            canvas.addEventListener('wheel', handleWheel);
            
            // Ï≤¥ÌÅ¨Î∞ïÏä§ Ïù¥Î≤§Ìä∏ (Íµ¨ ÏòµÏÖòÍ≥º Î™∏ ÏòµÏÖò Ï†úÍ±∞)
            document.getElementById('show-cylinders').addEventListener('change', () => loadFrame(currentFrame));
            document.getElementById('show-left-hand').addEventListener('change', () => loadFrame(currentFrame));
            document.getElementById('show-right-hand').addEventListener('change', () => loadFrame(currentFrame));
        }
        
        // Ïï†ÎãàÎ©îÏù¥ÏÖò Î£®ÌîÑ
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        
        // Ïπ¥Î©îÎùº Î∞©Ìñ• ÏóÖÎç∞Ïù¥Ìä∏
        function updateCameraDirection() {
            camera.rotation.order = 'YXZ';
            camera.rotation.y = yaw;
            camera.rotation.x = pitch;
            camera.rotation.z = roll;
        }
        
        // Ïπ¥Î©îÎùº ÏÉÅÌÉú Î°úÍ∑∏ Ï∂úÎ†•
        function logCameraState(action) {
            const yawDegrees = (yaw * 180 / Math.PI).toFixed(1);
            const pitchDegrees = (pitch * 180 / Math.PI).toFixed(1);
            const rollDegrees = (roll * 180 / Math.PI).toFixed(1);
            console.log(`[${action}] Ïπ¥Î©îÎùº ÏÉÅÌÉú:`, {
                ÏúÑÏπò: {
                    x: camera.position.x.toFixed(3),
                    y: camera.position.y.toFixed(3),
                    z: camera.position.z.toFixed(3)
                },
                Í∞ÅÎèÑ: {
                    yaw: yawDegrees + '¬∞',
                    pitch: pitchDegrees + '¬∞',
                    roll: rollDegrees + '¬∞'
                }
            });
        }
        
        // ÌÇ§Î≥¥Îìú Ïù¥Î≤§Ìä∏ Ï≤òÎ¶¨
        function handleKeyDown(e) {
            const moveSpeed = 0.1;
            const rotateSpeed = 0.1;
            let forward = new THREE.Vector3();
            let right = new THREE.Vector3();
            let up = new THREE.Vector3(0, 1, 0);
            camera.getWorldDirection(forward);
            right.crossVectors(forward, up).normalize();
            
            let moved = false;
            switch(e.key.toLowerCase()) {
                case 'w':
                    camera.position.add(forward.clone().multiplyScalar(moveSpeed));
                    moved = true;
                    break;
                case 's':
                    camera.position.add(forward.clone().multiplyScalar(-moveSpeed));
                    moved = true;
                    break;
                case 'a':
                    camera.position.add(right.clone().multiplyScalar(-moveSpeed));
                    moved = true;
                    break;
                case 'd':
                    camera.position.add(right.clone().multiplyScalar(moveSpeed));
                    moved = true;
                    break;
                case 'q':
                    camera.position.y += moveSpeed;
                    moved = true;
                    break;
                case 'e':
                    camera.position.y -= moveSpeed;
                    moved = true;
                    break;
                case 'z':
                    roll -= rotateSpeed;
                    updateCameraDirection();
                    moved = true;
                    break;
                case 'c':
                    roll += rotateSpeed;
                    updateCameraDirection();
                    moved = true;
                    break;
                case 'r':
                    resetCamera();
                    return; // resetCameraÏóêÏÑú Î°úÍ∑∏ Ï∂úÎ†•
            }
            
            if (moved) {
                logCameraState('ÌÇ§Î≥¥Îìú Ïù¥Îèô');
            }
        }
        
        // ÎßàÏö∞Ïä§ Ïù¥Î≤§Ìä∏ Ï≤òÎ¶¨
        function handleMouseDown(e) {
            isMouseDown = true;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
        }
        
        function handleMouseMove(e) {
            if (!isMouseDown) return;
            const deltaX = e.clientX - lastMouseX;
            const deltaY = e.clientY - lastMouseY;
            const rotateSpeed = 0.005;
            yaw -= deltaX * rotateSpeed;
            pitch -= deltaY * rotateSpeed;
            updateCameraDirection();
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
            
            logCameraState('ÎßàÏö∞Ïä§ ÌöåÏ†Ñ');
        }
        
        function handleMouseUp() {
            isMouseDown = false;
        }
        
        function handleWheel(e) {
            e.preventDefault();
            const moveSpeed = 0.2;
            let forward = new THREE.Vector3();
            camera.getWorldDirection(forward);
            camera.position.add(forward.clone().multiplyScalar(-e.deltaY * moveSpeed * 0.01));
            
            logCameraState('Ìú† Ï§å');
        }
        
        // ÌîÑÎ†àÏûÑ Î°úÎìú
        function loadFrame(frameIndex) {
            if (!data) return;
            currentFrame = frameIndex;
            clearScene();
            
            const showSpheres = false; // Íµ¨ ÏòµÏÖò ÎπÑÌôúÏÑ±Ìôî
            const showCylinders = document.getElementById('show-cylinders').checked;
            const showPose = true; // Î™∏ ÏòµÏÖò ÎπÑÌôúÏÑ±Ìôî
            const showLeftHand = document.getElementById('show-left-hand').checked;
            const showRightHand = document.getElementById('show-right-hand').checked;
            

            // Pose
            if (data.pose && data.pose[frameIndex] && showPose) {
                    const rotatedPose = data.pose[frameIndex].map(landmark => rotateLandmark(landmark, true));
                if (showSpheres) {
                    rotatedPose.forEach(lm => {
                        // Î©îÏù∏ Íµ¨
                        const geometry = new THREE.SphereGeometry(0.012, 12, 12);
                        const material = new THREE.MeshLambertMaterial({ 
                            color: POSE_COLOR,
                            emissive: POSE_COLOR,
                            emissiveIntensity: 0.1
                        });
                        const sphere = new THREE.Mesh(geometry, material);
                        sphere.position.set(lm[0], lm[1], lm[2]);
                        scene.add(sphere);
                        poseObjects.push(sphere);
                        
                        // Ïô∏Í≥ΩÏÑ† Íµ¨
                        const outlineGeometry = new THREE.SphereGeometry(0.016, 12, 12);
                        const outlineMaterial = new THREE.MeshBasicMaterial({ 
                            color: 0x000000, 
                            transparent: true, 
                            opacity: 0.6,
                            side: THREE.BackSide
                        });
                        const outlineSphere = new THREE.Mesh(outlineGeometry, outlineMaterial);
                        outlineSphere.position.set(lm[0], lm[1], lm[2]);
                        scene.add(outlineSphere);
                        poseObjects.push(outlineSphere);
                    });
                }
                if (showCylinders) {
                    drawConnectionsCylinder(rotatedPose, POSE_CONNECTIONS, POSE_COLOR, poseLines);
                }
            }
            
            // Left Hand
            if (data.left_hand && data.left_hand[frameIndex] && showLeftHand) {
                    const rotatedLeftHand = data.left_hand[frameIndex].map(landmark => rotateLandmark(landmark, false));
                if (showSpheres) {
                    rotatedLeftHand.forEach(lm => {
                        // Î©îÏù∏ Íµ¨
                        const geometry = new THREE.SphereGeometry(0.014, 12, 12);
                        const material = new THREE.MeshLambertMaterial({ 
                            color: LEFT_COLOR,
                            emissive: LEFT_COLOR,
                            emissiveIntensity: 0.1
                        });
                        const sphere = new THREE.Mesh(geometry, material);
                        sphere.position.set(lm[0], lm[1], lm[2]);
                        scene.add(sphere);
                        leftHandObjects.push(sphere);
                        
                        // Ïô∏Í≥ΩÏÑ† Íµ¨
                        const outlineGeometry = new THREE.SphereGeometry(0.018, 12, 12);
                        const outlineMaterial = new THREE.MeshBasicMaterial({ 
                            color: 0x000000, 
                            transparent: true, 
                            opacity: 0.6,
                            side: THREE.BackSide
                        });
                        const outlineSphere = new THREE.Mesh(outlineGeometry, outlineMaterial);
                        outlineSphere.position.set(lm[0], lm[1], lm[2]);
                        scene.add(outlineSphere);
                        leftHandObjects.push(outlineSphere);
                    });
                }
                if (showCylinders) {
                    drawConnectionsCylinder(rotatedLeftHand, HAND_CONNECTIONS, LEFT_COLOR, leftHandLines);
                }
            }
            
            // Right Hand
            if (data.right_hand && data.right_hand[frameIndex] && showRightHand) {
                    const rotatedRightHand = data.right_hand[frameIndex].map(landmark => rotateLandmark(landmark, false));

                if (showSpheres) {
                    rotatedRightHand.forEach(lm => {
                        // Î©îÏù∏ Íµ¨
                        const geometry = new THREE.SphereGeometry(0.014, 12, 12);
                        const material = new THREE.MeshLambertMaterial({ 
                            color: RIGHT_COLOR,
                            emissive: RIGHT_COLOR,
                            emissiveIntensity: 0.1
                        });
                        const sphere = new THREE.Mesh(geometry, material);
                        sphere.position.set(lm[0], lm[1], lm[2]);
                        scene.add(sphere);
                        rightHandObjects.push(sphere);
                        
                        // Ïô∏Í≥ΩÏÑ† Íµ¨
                        const outlineGeometry = new THREE.SphereGeometry(0.018, 12, 12);
                        const outlineMaterial = new THREE.MeshBasicMaterial({ 
                            color: 0x000000, 
                            transparent: true, 
                            opacity: 0.6,
                            side: THREE.BackSide
                        });
                        const outlineSphere = new THREE.Mesh(outlineGeometry, outlineMaterial);
                        outlineSphere.position.set(lm[0], lm[1], lm[2]);
                        scene.add(outlineSphere);
                        rightHandObjects.push(outlineSphere);
                    });
                }
                if (showCylinders) {
                    drawConnectionsCylinder(rotatedRightHand, HAND_CONNECTIONS, RIGHT_COLOR, rightHandLines);
                }
            }
            
            document.getElementById('current-frame').textContent = currentFrame;
            document.getElementById('frame-slider').value = currentFrame;
        }
        
        // Ïî¨ ÌÅ¥Î¶¨Ïñ¥
        function clearScene() {
            [...poseObjects, ...leftHandObjects, ...rightHandObjects].forEach(obj => {
                scene.remove(obj);
                if (obj.geometry) obj.geometry.dispose();
                if (obj.material) obj.material.dispose();
            });
            [...poseLines, ...leftHandLines, ...rightHandLines].forEach(line => {
                scene.remove(line);
                if (line.geometry) line.geometry.dispose();
                if (line.material) line.material.dispose();
            });
            poseObjects = []; leftHandObjects = []; rightHandObjects = [];
            poseLines = []; leftHandLines = []; rightHandLines = [];
        }
        
        // Ïó∞Í≤∞ÏÑ† Í∑∏Î¶¨Í∏∞
        function drawConnectionsCylinder(landmarks, connections, color, lineArray) {
            connections.forEach(connection => {
                if (connection[0] < landmarks.length && connection[1] < landmarks.length) {
                    const start = landmarks[connection[0]];
                    const end = landmarks[connection[1]];
                    let is34 = false;
                    let ISright = false;

                    if(color == 0xd63031)
                        ISright = true;
                    else
                        ISright = false;
                    
                    if(connection[0] === 3 && connection[1] === 4
                        || connection[0] === 7 && connection[1] === 8
                        || connection[0] === 11 && connection[1] === 12
                        || connection[0] === 15 && connection[1] === 16
                        || connection[0] === 19 && connection[1] === 20
                    )
                        {
                            is34 = true;
                        }
                    const startVec = new THREE.Vector3(start[0], start[1], start[2]);
                    const endVec = new THREE.Vector3(end[0], end[1], end[2]);
                    const distance = startVec.distanceTo(endVec);
                    
                    // Î©îÏù∏ ÏõêÍ∏∞Îë• (Îçî ÏßÑÌïú ÏÉâÏÉÅ)
                    const geometry = new THREE.CylinderGeometry(0.008, 0.008, distance, 12);

                    if(is34)
                    {
                     if(ISright)
                    {
                        const material = new THREE.MeshLambertMaterial({ 
                        color: 0xffc4c4, 
                        transparent: true, 
                        opacity: 0.9,
                        emissive: color,
                        emissiveIntensity: 0.1
                    });
                    const cylinder = new THREE.Mesh(geometry, material);
                    cylinder.position.copy(startVec).add(endVec).multiplyScalar(0.5);
                    const up = new THREE.Vector3(0, 1, 0);
                    const quaternion = new THREE.Quaternion().setFromUnitVectors(up, new THREE.Vector3().subVectors(endVec, startVec).normalize());
                    cylinder.quaternion.copy(quaternion);
                    scene.add(cylinder);
                    lineArray.push(cylinder);

                                        const outlineGeometry = new THREE.CylinderGeometry(0.012, 0.012, distance, 12);
                    const outlineMaterial = new THREE.MeshBasicMaterial({ 
                        color: 0xffffff , 
                        transparent: true, 
                        opacity: 0.6,
                        side: THREE.BackSide
                    });
                    const outlineCylinder = new THREE.Mesh(outlineGeometry, outlineMaterial);
                    outlineCylinder.position.copy(cylinder.position);
                    outlineCylinder.quaternion.copy(cylinder.quaternion);
                    scene.add(outlineCylinder);
                    lineArray.push(outlineCylinder);
                    }   
                    else
                    {
                        const material = new THREE.MeshLambertMaterial({ 
                        color: 0xcffffc, 
                        transparent: true, 
                        opacity: 0.9,
                        emissive: color,
                        emissiveIntensity: 0.1
                    });
                    const cylinder = new THREE.Mesh(geometry, material);
                    cylinder.position.copy(startVec).add(endVec).multiplyScalar(0.5);
                    const up = new THREE.Vector3(0, 1, 0);
                    const quaternion = new THREE.Quaternion().setFromUnitVectors(up, new THREE.Vector3().subVectors(endVec, startVec).normalize());
                    cylinder.quaternion.copy(quaternion);
                    scene.add(cylinder);
                    lineArray.push(cylinder);

                                        const outlineGeometry = new THREE.CylinderGeometry(0.012, 0.012, distance, 12);
                    const outlineMaterial = new THREE.MeshBasicMaterial({ 
                        color: 0xffffff , 
                        transparent: true, 
                        opacity: 0.6,
                        side: THREE.BackSide
                    });
                    const outlineCylinder = new THREE.Mesh(outlineGeometry, outlineMaterial);
                    outlineCylinder.position.copy(cylinder.position);
                    outlineCylinder.quaternion.copy(cylinder.quaternion);
                    scene.add(outlineCylinder);
                    lineArray.push(outlineCylinder);
                    }
                        
                    }
                    else
                    {
                        const material = new THREE.MeshLambertMaterial({ 
                        color: color, 
                        transparent: true, 
                        opacity: 0.9,
                        emissive: color,
                        emissiveIntensity: 0.1
                    });
                                        const cylinder = new THREE.Mesh(geometry, material);
                    cylinder.position.copy(startVec).add(endVec).multiplyScalar(0.5);
                    const up = new THREE.Vector3(0, 1, 0);
                    const quaternion = new THREE.Quaternion().setFromUnitVectors(up, new THREE.Vector3().subVectors(endVec, startVec).normalize());
                    cylinder.quaternion.copy(quaternion);
                    scene.add(cylinder);
                    lineArray.push(cylinder);

                                        const outlineGeometry = new THREE.CylinderGeometry(0.012, 0.012, distance, 12);
                    const outlineMaterial = new THREE.MeshBasicMaterial({ 
                        color: 0xffffff , 
                        transparent: true, 
                        opacity: 0.6,
                        side: THREE.BackSide
                    });
                    const outlineCylinder = new THREE.Mesh(outlineGeometry, outlineMaterial);
                    outlineCylinder.position.copy(cylinder.position);
                    outlineCylinder.quaternion.copy(cylinder.quaternion);
                    scene.add(outlineCylinder);
                    lineArray.push(outlineCylinder);
                    }


                }
            });
        }
        
        // Ïª®Ìä∏Î°§ Ìï®ÏàòÎì§
        function previousFrame() {
            if (currentFrame > 0) {
                loadFrame(currentFrame - 1);
            }
        }
        
        function nextFrame() {
            if (data && currentFrame < data.pose.length - 1) {
                loadFrame(currentFrame + 1);
            }
        }
        
        function playAnimation() {
            if (isPlaying) {
                isPlaying = false;
                if (animationInterval) {
                    clearInterval(animationInterval);
                    animationInterval = null;
                }
                document.getElementById('play-btn').textContent = '‚ñ∂ Ïû¨ÏÉù';
            } else {
                isPlaying = true;
                document.getElementById('play-btn').textContent = '‚è∏ Ï†ïÏßÄ';
                animationInterval = setInterval(() => {
                    if (data && currentFrame < data.pose.length - 1) {
                        loadFrame(currentFrame + 1);
                    } else {
                        loadFrame(0);
                    }
                }, 1000 / animationSpeed);
            }
        }
        
        function resetCamera() {
            camera.position.set(cameraInitPos.x, cameraInitPos.y, cameraInitPos.z);
            yaw = -10.3 * Math.PI / 180;
            pitch = 178.7 * Math.PI / 180;
            roll = 0 * Math.PI / 180;
            updateCameraDirection();
            logCameraState('Ïπ¥Î©îÎùº Î¶¨ÏÖã');
        }
        
        function sliderFrame(val) {
            loadFrame(parseInt(val));
        }
        
        function updateSpeed() {
            animationSpeed = parseInt(document.getElementById('speed').value);
            document.getElementById('speed-value').textContent = animationSpeed;
            if (isPlaying && animationInterval) {
                clearInterval(animationInterval);
                playAnimation();
            }
        }
        
        // ÏúàÎèÑÏö∞ Î¶¨ÏÇ¨Ïù¥Ï¶à Ï≤òÎ¶¨
        window.addEventListener('resize', () => {
            const canvas = document.getElementById('landmark-canvas');
            camera.aspect = canvas.offsetWidth / canvas.offsetHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(canvas.offsetWidth, canvas.offsetHeight);
        });

        // Ìè¨Ï¶à Ïò§ÌîÑÏÖã ÏóÖÎç∞Ïù¥Ìä∏ Ìï®Ïàò
function updatePoseOffset(axis, value) {
    value = parseFloat(value);
    poseOffset[axis] = value;
    document.getElementById(`pose-${axis}`).value = value.toFixed(3);
    if (currentFrame >= 0) {
        loadFrame(currentFrame);  // ÌòÑÏû¨ ÌîÑÎ†àÏûÑ Îã§Ïãú Î°úÎìú
    }
}

// Ìè¨Ï¶à Ïä§ÏºÄÏùº ÏóÖÎç∞Ïù¥Ìä∏ Ìï®Ïàò
function updatePoseScale(value) {
    poseScale = parseFloat(value);
    document.getElementById('pose-scale').value = poseScale.toFixed(3);
    if (currentFrame >= 0) {
        loadFrame(currentFrame);  // ÌòÑÏû¨ ÌîÑÎ†àÏûÑ Îã§Ïãú Î°úÎìú
    }
}
    </script>
</body>
</html> 