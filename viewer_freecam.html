<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prototype Viewer - ëœë“œë§ˆí¬ vs ì›¹ìº  ë¹„êµ</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            height: 100vh;
            overflow: hidden;
        }
        .header {
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            padding: 15px 30px;
            color: #333;
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
        }
        .header-content {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 30px;
        }
        .header-title {
            flex-shrink: 0;
        }
        .header-title h1 {
            font-size: 24px;
            font-weight: 300;
            margin-bottom: 5px;
            color: #2c3e50;
        }
        .header-title p {
            font-size: 14px;
            opacity: 0.7;
            color: #34495e;
            margin: 0;
        }
        .header-controls {
            display: flex;
            align-items: center;
            gap: 20px;
            flex-wrap: wrap;
        }
        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .control-group label {
            color: #2c3e50;
            font-size: 12px;
            font-weight: 500;
            white-space: nowrap;
        }
        .control-buttons {
            display: flex;
            gap: 5px;
        }
        .control-buttons button {
            padding: 6px 12px;
            font-size: 11px;
        }
        .control-toggles {
            display: flex;
            gap: 15px;
        }
        .control-toggles label {
            color: #2c3e50;
            font-size: 12px;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .main-container {
            display: flex;
            height: calc(100vh - 80px);
        }
        .left-panel, .right-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            position: relative;
        }
        .left-panel {
            background: rgba(255, 255, 255, 0.95);
            border-right: 2px solid rgba(0, 0, 0, 0.1);
        }
        .right-panel {
            background: rgba(255, 255, 255, 0.95);
        }
        .panel-title {
            background: rgba(52, 73, 94, 0.9);
            color: white;
            padding: 10px 20px;
            font-size: 16px;
            font-weight: 500;
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
        }
        .controls {
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
        }
        .control-row {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 10px;
        }
        .control-row:last-child { margin-bottom: 0; }
        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .control-group label {
            color: #2c3e50;
            font-size: 12px;
            min-width: 60px;
            font-weight: 500;
        }
        select, input[type="range"] {
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid rgba(0, 0, 0, 0.2);
            color: #2c3e50;
            padding: 5px 8px;
            border-radius: 4px;
            font-size: 12px;
        }
        select option {
            background: #fff;
            color: #2c3e50;
        }
        button {
            background: linear-gradient(45deg, #3498db, #2980b9);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s ease;
        }
        button:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.3);
        }
        button:active {
            transform: translateY(0);
        }
        .canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            background: #f8f9fa;
        }
        #landmark-canvas, #webcam-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        .webcam-container {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #f8f9fa;
            position: relative;
        }
        #webcam-video {
            max-width: 100%;
            max-height: 100%;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }
        #webcam-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            border-radius: 8px;
        }
        .webcam-overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.9);
            color: #2c3e50;
            padding: 10px 15px;
            border-radius: 6px;
            font-size: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        .status-indicator {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #e74c3c;
        }
        .status-indicator.active {
            background: #27ae60;
            box-shadow: 0 0 10px #27ae60;
        }
        .info-text {
            color: #7f8c8d;
            font-size: 11px;
            margin-top: 5px;
        }
        .legend {
            display: flex;
            gap: 15px;
            margin-top: 10px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
            color: #2c3e50;
            font-size: 11px;
        }
        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="header-content">
            <div class="header-title">
                <h1>Prototype Viewer</h1>
                <p>ëœë“œë§ˆí¬ ì• ë‹ˆë©”ì´ì…˜ vs ì‹¤ì‹œê°„ ì›¹ìº  ë¹„êµ</p>
            </div>
            <div class="header-controls">
                <div class="control-group">
    <label>í¬ì¦ˆ X:</label>
    <input type="number" id="pose-x" value="0" step="0.001" style="width: 60px;" oninput="updatePoseOffset('x', this.value)">
</div>
<div class="control-group">
    <label>í¬ì¦ˆ Y:</label>
    <input type="number" id="pose-y" value="0" step="0.001" style="width: 60px;" oninput="updatePoseOffset('y', this.value)">
</div>
<div class="control-group">
    <label>í¬ì¦ˆ Z:</label>
    <input type="number" id="pose-z" value="-0.3" step="0.001" style="width: 60px;" oninput="updatePoseOffset('z', this.value)">
</div>
<div class="control-group">
    <label>í¬ì¦ˆ í¬ê¸°:</label>
    <input type="number" id="pose-scale" value="0.8" step="0.001" style="width: 60px;" oninput="updatePoseScale(this.value)">
</div>
                <div class="control-group">
                    <label>ë¹„ë””ì˜¤:</label>
                    <select id="video-select"></select>
                </div>
                <div class="control-group">
                    <label>í”„ë ˆì„:</label>
                    <span id="current-frame">0</span>
                </div>
                <div class="control-buttons">
                    <button onclick="previousFrame()">â—€</button>
                    <button onclick="playAnimation()" id="play-btn">â–¶</button>
                    <button onclick="nextFrame()">â–¶</button>
                    <button onclick="resetCamera()">ğŸ”„</button>
                </div>
                <div class="control-group">
                    <label>í”„ë ˆì„:</label>
                    <input type="range" id="frame-slider" min="0" max="0" value="0" style="width: 120px;" oninput="sliderFrame(this.value)">
                </div>
                <div class="control-group">
                    <label>ì†ë„:</label>
                    <input type="range" id="speed" min="1" max="30" value="5" onchange="updateSpeed()" style="width: 80px;">
                    <span id="speed-value">5</span>
                </div>
                <div class="control-toggles">
                    <label><input type="checkbox" id="show-cylinders" checked> ì›ê¸°ë‘¥(ì„ )</label>
                    <label><input type="checkbox" id="show-left-hand" checked> ì¢Œì¸¡ ì†</label>
                    <label><input type="checkbox" id="show-right-hand" checked> ìš°ì¸¡ ì†</label>
                </div>
            </div>
        </div>
    </div>
    
    <div class="main-container">
        <!-- ì¢Œì¸¡ íŒ¨ë„: ëœë“œë§ˆí¬ ë·°ì–´ (ì „ì²´ ê³µê°„) -->
        <div class="left-panel">
            <div class="panel-title">3D ëœë“œë§ˆí¬ ë·°ì–´</div>
            <div class="canvas-container">
                <canvas id="landmark-canvas"></canvas>
            </div>
        </div>
        
        <!-- ìš°ì¸¡ íŒ¨ë„: ì›¹ìº  + ì»¨íŠ¸ë¡¤ -->
        <div class="right-panel">
            <div class="panel-title">ì‹¤ì‹œê°„ ì›¹ìº </div>
            
            <div class="webcam-container">
                <video id="webcam-video" autoplay muted playsinline></video>
                <canvas id="webcam-overlay" style="position: absolute; top: 0; left: 0; pointer-events: none;"></canvas>
                <div class="webcam-overlay">
                    <div>ì›¹ìº  ìŠ¤íŠ¸ë¦¼</div>
                    <div id="webcam-status">ì—°ê²° ì¤‘...</div>
                </div>
                <div class="status-indicator" id="webcam-indicator"></div>
            </div>
        </div>
    </div>

    <script>
        // ëœë“œë§ˆí¬ ë·°ì–´ ê´€ë ¨ ë³€ìˆ˜ë“¤
        let scene, camera, renderer;
        let poseObjects = [], leftHandObjects = [], rightHandObjects = [];
        let poseLines = [], leftHandLines = [], rightHandLines = [];
        let currentFrame = 0;
        let isPlaying = false;
        let animationSpeed = 30;
        let animationInterval;
        let allData = null;
        let data = null;
        
        // ì¹´ë©”ë¼ ì»¨íŠ¸ë¡¤ ë³€ìˆ˜ (í”Œë¼ì´/í”„ë¦¬ ë¬´ë¸Œ)
        // ì´ˆê¸° ì¹´ë©”ë¼ ì„¤ì •:
        // - ìœ„ì¹˜: (-0.388, 0.334, -0.655) - ì‚¬ìš©ì ì§€ì • ìœ„ì¹˜
        // - Yaw: -10.3ë„ (ì¢Œìš° íšŒì „) - ì‚¬ìš©ì ì§€ì • ê°ë„
        // - Pitch: 178.7ë„ (ìƒí•˜ íšŒì „) - ì‚¬ìš©ì ì§€ì • ê°ë„
        // - Roll: 0ë„ (ì‹œì  íšŒì „) - ì‚¬ìš©ì ì§€ì • ê°ë„
        let cameraInitPos = { x: 0.453, y: 0.489, z: 0.592 };
        let cameraInitRot = { x: 0, y: 0, z: 0 };
        let isMouseDown = false;
        let lastMouseX = 0, lastMouseY = 0;
        let yaw = 0;
        let pitch = 0;
        let roll = 0;
        // ëœë“œë§ˆí¬ ë·°ì–´ ê´€ë ¨ ë³€ìˆ˜ë“¤ ë¶€ë¶„ì— ì¶”ê°€
let poseScale = 0.8;  // í¬ì¦ˆ í¬ê¸° ì¡°ì ˆ
let poseOffset = { x: -0.090, y: 0.098, z: -0.934 };  // í¬ì¦ˆ ìœ„ì¹˜ ì¡°ì ˆ (-0.3 + -0.634 = -0.934)


        // ìƒ‰ìƒ
        const POSE_COLOR = 0x00b894;
        const LEFT_COLOR = 0xF4A258;
        const RIGHT_COLOR = 0x5fa5fb;
        
        // ì—°ê²° êµ¬ì¡°
        // í¬ì¦ˆ ìš°ì¸¡ ì† [15,17],[15,19],[15,21],[17,19]
        // í¬ì¦ˆ ì¢Œì¸¡ ì† [16,18],[16,20],[16,22],[18,20]

        // ì–¼êµ´  [0,1],[1,2],[2,3],[3,7],[0,4],[4,5],[5,6],[6,8],
        const POSE_CONNECTIONS = [
           [9,10],[11,12],[11,13],[13,15],[12,14],[14,16],[11,23],[12,24]
        ];
        const HAND_CONNECTIONS = [
            [0,1],[1,2],[2,3],[3,4],
            [0,5],[5,6],[6,7],[7,8],
            [0,9],[9,10],[10,11],[11,12],
            [0,13],[13,14],[14,15],[15,16],
            [0,17],[17,18],[18,19],[19,20],
            [5,9],[9,13],[13,17],[5,17]
        ];
        
        // ì›¹ìº  ê´€ë ¨ ë³€ìˆ˜
        let webcamStream = null;
        let webcamVideo = null;
        
        // ì´ˆê¸°í™”
        window.onload = function() {
            // ì´ˆê¸° í¬ì¦ˆ ì˜¤í”„ì…‹ ê°’ ì„¤ì •
            document.getElementById('pose-x').value = poseOffset.x.toFixed(3);
            document.getElementById('pose-y').value = poseOffset.y.toFixed(3);
            document.getElementById('pose-z').value = poseOffset.z.toFixed(3);
            document.getElementById('pose-scale').value = poseScale.toFixed(3);
            
            initLandmarkViewer();
        };
        
        // ì—°ê²° êµ¬ì¡° ì •ì˜ ì•„ë˜ì— ì¶”ê°€
// ëœë“œë§ˆí¬ íšŒì „ ë° ì¡°ì • í•¨ìˆ˜
function rotateLandmark(landmark, isBody = false) {
    // ê¸°ë³¸ íšŒì „ (xì™€ z ì¢Œí‘œ ë°˜ì „)
    let result = [-landmark[0], landmark[1], -landmark[2]];
    
    // í¬ì¦ˆ(ì‹ ì²´)ì¸ ê²½ìš°ì—ë§Œ ìŠ¤ì¼€ì¼ ë° ì˜¤í”„ì…‹ ì ìš©
    if (isBody) {
        result[0] = result[0] * poseScale + poseOffset.x;
        result[1] = result[1] * poseScale + poseOffset.y;
        result[2] = result[2] * poseScale + poseOffset.z;
    }
    
    return result;
}

        // ëœë“œë§ˆí¬ ë·°ì–´ ì´ˆê¸°í™”
        function initLandmarkViewer() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xdbdbdb);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / 2 / window.innerHeight, 0.001, 1000);
            camera.position.set(cameraInitPos.x, cameraInitPos.y, cameraInitPos.z);
            camera.rotation.set(cameraInitRot.x, cameraInitRot.y, cameraInitRot.z);

            yaw = -186.2 * Math.PI / 180;
            pitch = 192.5 * Math.PI / 180;
            roll = 0 * Math.PI / 180;
            // yaw = -10.3 * Math.PI / 180;
            // pitch = 178.7 * Math.PI / 180;
            // roll = 0 * Math.PI / 180;

            updateCameraDirection();
            
            const canvas = document.getElementById('landmark-canvas');
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true, alpha: true });
            renderer.setSize(canvas.offsetWidth, canvas.offsetHeight);
            renderer.setClearColor(0xf8f9fa, 1);


            
            const ambientLight = new THREE.AmbientLight(0x404040, 0.8);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);
            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight2.position.set(-1, 1, -1);
            scene.add(directionalLight2);

            // ì¢Œìš°ë°˜ì „ ì ìš©
            const mirrorMatrix = new THREE.Matrix4().makeScale(-1, 1, 1);
            scene.applyMatrix4(mirrorMatrix);
            
            // ë°ì´í„° ë¡œë“œ
            loadLandmarkData();
            
            // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
            setupEventListeners();
            
            animate();
            
            // ì´ˆê¸° ì¹´ë©”ë¼ ìƒíƒœ ë¡œê·¸
            logCameraState('ì´ˆê¸°í™”');
        }
     
        
        // MediaPipe Tasks Vision ì´ˆê¸°í™”
        let handLandmarker = null;
        let webcamOverlay = null;
        let webcamCtx = null;
        
     
        
        function drawHandLandmarks(landmarks, color) {
            // ì† ì—°ê²°ì„  ì •ì˜
            const HAND_CONNECTIONS = [
                [0,1],[1,2],[2,3],[3,4],
                [0,5],[5,6],[6,7],[7,8],
                [0,9],[9,10],[10,11],[11,12],
                [0,13],[13,14],[14,15],[15,16],
                [0,17],[17,18],[18,19],[19,20],
                [5,9],[9,13],[13,17],[5,17]
            ];
            
            // ì—°ê²°ì„  ê·¸ë¦¬ê¸°
            HAND_CONNECTIONS.forEach(([start, end]) => {
                const startPoint = landmarks[start];
                const endPoint = landmarks[end];
                
                if (startPoint && endPoint) {
                    const startX = startPoint.x * webcamOverlay.width;
                    const startY = startPoint.y * webcamOverlay.height;
                    const endX = endPoint.x * webcamOverlay.width;
                    const endY = endPoint.y * webcamOverlay.height;
                    
                    webcamCtx.strokeStyle = color;
                    webcamCtx.lineWidth = 2;
                    webcamCtx.beginPath();
                    webcamCtx.moveTo(startX, startY);
                    webcamCtx.lineTo(endX, endY);
                    webcamCtx.stroke();
                }
            });
            
            // ëœë“œë§ˆí¬ ì  ê·¸ë¦¬ê¸°
            landmarks.forEach(landmark => {
                const x = landmark.x * webcamOverlay.width;
                const y = landmark.y * webcamOverlay.height;
                
                webcamCtx.fillStyle = color;
                webcamCtx.beginPath();
                webcamCtx.arc(x, y, 3, 0, 2 * Math.PI);
                webcamCtx.fill();
            });
        }
        
        // ëœë“œë§ˆí¬ ë°ì´í„° ë¡œë“œ
        function loadLandmarkData() {
            // file_list.jsonì—ì„œ íŒŒì¼ ëª©ë¡ ë¡œë“œ
            fetch('file_list.json')
                .then(response => {
                    if (!response.ok) {
                        throw new Error('file_list.json ë¡œë“œ ì‹¤íŒ¨');
                    }
                    return response.json();
                })
                .then(fileList => {
                    const jsonFiles = fileList.landmark_files || [];
                    console.log('íŒŒì¼ ëª©ë¡ì—ì„œ ë°œê²¬ëœ íŒŒì¼ë“¤:', jsonFiles);
                    
                    if (jsonFiles.length === 0) {
                        throw new Error('file_list.jsonì— íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤.');
                    }
                    
                    // ê° íŒŒì¼ì„ ë¡œë“œ
                    const loadPromises = jsonFiles.map(filename => 
                        fetch(`result/${filename}`)
                            .then(response => {
                                if (!response.ok) {
                                    throw new Error(`HTTP ${response.status}`);
                                }
                                return response.json();
                            })
                            .then(data => ({ filename, data }))
                            .catch(error => {
                                console.warn(`íŒŒì¼ ë¡œë“œ ì‹¤íŒ¨: ${filename} - ${error.message}`);
                                return null;
                            })
                    );
                    
                    return Promise.all(loadPromises);
                })
                .then(results => {
                    const validResults = results.filter(result => result !== null);
                    
                    if (validResults.length === 0) {
                        throw new Error('ë¡œë“œ ê°€ëŠ¥í•œ JSON íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤.');
                    }
                    
                    console.log('ì„±ê³µì ìœ¼ë¡œ ë¡œë“œëœ íŒŒì¼ë“¤:', validResults.map(r => r.filename));
                    return validResults;
                })
                .then(results => {
                    // allDataë¥¼ íŒŒì¼ëª…ì„ í‚¤ë¡œ í•˜ëŠ” ê°ì²´ë¡œ êµ¬ì„±
                    allData = {};
                    results.forEach(({ filename, data }) => {
                        const baseName = filename.replace('_landmarks.json', '');
                        allData[baseName] = data;
                    });
                    
                    const select = document.getElementById('video-select');
                    
                    // íŒŒì¼ ì„ íƒ ì˜µì…˜ ìƒì„±
                    Object.keys(allData).forEach(filename => {
                        const opt = document.createElement('option');
                        opt.value = filename;
                        opt.textContent = filename;
                        select.appendChild(opt);
                    });
                    
                    select.onchange = function() {
                        data = allData[select.value];
                        document.getElementById('frame-slider').max = data.pose.length - 1;
                        loadFrame(0);
                    };
                    
                    select.value = Object.keys(allData)[0];
                    select.onchange();
                })
                .catch(error => {
                    console.error('ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨:', error);
                    document.querySelector('.left-panel').innerHTML = `
                        <div style="color: white; padding: 20px; text-align: center;">
                            <h3>ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨</h3>
                            <p>${error.message}</p>
                            <p>result ë””ë ‰í† ë¦¬ì— JSON íŒŒì¼ì´ ìˆëŠ”ì§€ í™•ì¸í•´ì£¼ì„¸ìš”.</p>
                        </div>
                    `;
                });
        }
        
        // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì„¤ì •
        function setupEventListeners() {
            // í‚¤ë³´ë“œ ì»¨íŠ¸ë¡¤ (ì‹œì  ì´ë™ í™œì„±í™”)
            document.addEventListener('keydown', handleKeyDown);
            
            // ë§ˆìš°ìŠ¤ ì»¨íŠ¸ë¡¤ (ì‹œì  ì´ë™ í™œì„±í™”)
            const canvas = document.getElementById('landmark-canvas');
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('mouseleave', handleMouseUp);
            canvas.addEventListener('wheel', handleWheel);
            
            // ì²´í¬ë°•ìŠ¤ ì´ë²¤íŠ¸ (êµ¬ ì˜µì…˜ê³¼ ëª¸ ì˜µì…˜ ì œê±°)
            document.getElementById('show-cylinders').addEventListener('change', () => loadFrame(currentFrame));
            document.getElementById('show-left-hand').addEventListener('change', () => loadFrame(currentFrame));
            document.getElementById('show-right-hand').addEventListener('change', () => loadFrame(currentFrame));
        }
        
        // ì• ë‹ˆë©”ì´ì…˜ ë£¨í”„
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        
        // ì¹´ë©”ë¼ ë°©í–¥ ì—…ë°ì´íŠ¸
        function updateCameraDirection() {
            camera.rotation.order = 'YXZ';
            camera.rotation.y = yaw;
            camera.rotation.x = pitch;
            camera.rotation.z = roll;
        }
        
        // ì¹´ë©”ë¼ ìƒíƒœ ë¡œê·¸ ì¶œë ¥
        function logCameraState(action) {
            const yawDegrees = (yaw * 180 / Math.PI).toFixed(1);
            const pitchDegrees = (pitch * 180 / Math.PI).toFixed(1);
            const rollDegrees = (roll * 180 / Math.PI).toFixed(1);
            console.log(`[${action}] ì¹´ë©”ë¼ ìƒíƒœ:`, {
                ìœ„ì¹˜: {
                    x: camera.position.x.toFixed(3),
                    y: camera.position.y.toFixed(3),
                    z: camera.position.z.toFixed(3)
                },
                ê°ë„: {
                    yaw: yawDegrees + 'Â°',
                    pitch: pitchDegrees + 'Â°',
                    roll: rollDegrees + 'Â°'
                }
            });
        }
        
        // í‚¤ë³´ë“œ ì´ë²¤íŠ¸ ì²˜ë¦¬
        function handleKeyDown(e) {
            const moveSpeed = 0.1;
            const rotateSpeed = 0.1;
            let forward = new THREE.Vector3();
            let right = new THREE.Vector3();
            let up = new THREE.Vector3(0, 1, 0);
            camera.getWorldDirection(forward);
            right.crossVectors(forward, up).normalize();
            
            let moved = false;
            switch(e.key.toLowerCase()) {
                case 'w':
                    camera.position.add(forward.clone().multiplyScalar(moveSpeed));
                    moved = true;
                    break;
                case 's':
                    camera.position.add(forward.clone().multiplyScalar(-moveSpeed));
                    moved = true;
                    break;
                case 'a':
                    camera.position.add(right.clone().multiplyScalar(-moveSpeed));
                    moved = true;
                    break;
                case 'd':
                    camera.position.add(right.clone().multiplyScalar(moveSpeed));
                    moved = true;
                    break;
                case 'q':
                    camera.position.y += moveSpeed;
                    moved = true;
                    break;
                case 'e':
                    camera.position.y -= moveSpeed;
                    moved = true;
                    break;
                case 'z':
                    roll -= rotateSpeed;
                    updateCameraDirection();
                    moved = true;
                    break;
                case 'c':
                    roll += rotateSpeed;
                    updateCameraDirection();
                    moved = true;
                    break;
                case 'r':
                    resetCamera();
                    return; // resetCameraì—ì„œ ë¡œê·¸ ì¶œë ¥
            }
            
            if (moved) {
                logCameraState('í‚¤ë³´ë“œ ì´ë™');
            }
        }
        
        // ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸ ì²˜ë¦¬
        function handleMouseDown(e) {
            isMouseDown = true;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
        }
        
        function handleMouseMove(e) {
            if (!isMouseDown) return;
            const deltaX = e.clientX - lastMouseX;
            const deltaY = e.clientY - lastMouseY;
            const rotateSpeed = 0.005;
            yaw -= deltaX * rotateSpeed;
            pitch -= deltaY * rotateSpeed;
            updateCameraDirection();
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
            
            logCameraState('ë§ˆìš°ìŠ¤ íšŒì „');
        }
        
        function handleMouseUp() {
            isMouseDown = false;
        }
        
        function handleWheel(e) {
            e.preventDefault();
            const moveSpeed = 0.2;
            let forward = new THREE.Vector3();
            camera.getWorldDirection(forward);
            camera.position.add(forward.clone().multiplyScalar(-e.deltaY * moveSpeed * 0.01));
            
            logCameraState('íœ  ì¤Œ');
        }
        
        // í”„ë ˆì„ ë¡œë“œ
        function loadFrame(frameIndex) {
            if (!data) return;
            currentFrame = frameIndex;
            clearScene();
            
            const showSpheres = false; // êµ¬ ì˜µì…˜ ë¹„í™œì„±í™”
            const showCylinders = document.getElementById('show-cylinders').checked;
            const showPose = true; // ëª¸ ì˜µì…˜ ë¹„í™œì„±í™”
            const showLeftHand = document.getElementById('show-left-hand').checked;
            const showRightHand = document.getElementById('show-right-hand').checked;
            

            // Pose
            if (data.pose && data.pose[frameIndex] && showPose) {
                    const rotatedPose = data.pose[frameIndex].map(landmark => rotateLandmark(landmark, true));
                if (showSpheres) {
                    rotatedPose.forEach(lm => {
                        // ë©”ì¸ êµ¬
                        const geometry = new THREE.SphereGeometry(0.012, 12, 12);
                        const material = new THREE.MeshLambertMaterial({ 
                            color: POSE_COLOR,
                            emissive: POSE_COLOR,
                            emissiveIntensity: 0.1
                        });
                        const sphere = new THREE.Mesh(geometry, material);
                        sphere.position.set(lm[0], lm[1], lm[2]);
                        scene.add(sphere);
                        poseObjects.push(sphere);
                        
                        // ì™¸ê³½ì„  êµ¬
                        const outlineGeometry = new THREE.SphereGeometry(0.016, 12, 12);
                        const outlineMaterial = new THREE.MeshBasicMaterial({ 
                            color: 0x000000, 
                            transparent: true, 
                            opacity: 0.6,
                            side: THREE.BackSide
                        });
                        const outlineSphere = new THREE.Mesh(outlineGeometry, outlineMaterial);
                        outlineSphere.position.set(lm[0], lm[1], lm[2]);
                        scene.add(outlineSphere);
                        poseObjects.push(outlineSphere);
                    });
                }
                if (showCylinders) {
                    drawConnectionsCylinder(rotatedPose, POSE_CONNECTIONS, POSE_COLOR, poseLines);
                }
            }
            
            // Left Hand
            if (data.left_hand && data.left_hand[frameIndex] && showLeftHand) {
                    const rotatedLeftHand = data.left_hand[frameIndex].map(landmark => rotateLandmark(landmark, false));
                if (showSpheres) {
                    rotatedLeftHand.forEach(lm => {
                        // ë©”ì¸ êµ¬
                        const geometry = new THREE.SphereGeometry(0.014, 12, 12);
                        const material = new THREE.MeshLambertMaterial({ 
                            color: LEFT_COLOR,
                            emissive: LEFT_COLOR,
                            emissiveIntensity: 0.1
                        });
                        const sphere = new THREE.Mesh(geometry, material);
                        sphere.position.set(lm[0], lm[1], lm[2]);
                        scene.add(sphere);
                        leftHandObjects.push(sphere);
                        
                        // ì™¸ê³½ì„  êµ¬
                        const outlineGeometry = new THREE.SphereGeometry(0.018, 12, 12);
                        const outlineMaterial = new THREE.MeshBasicMaterial({ 
                            color: 0x000000, 
                            transparent: true, 
                            opacity: 0.6,
                            side: THREE.BackSide
                        });
                        const outlineSphere = new THREE.Mesh(outlineGeometry, outlineMaterial);
                        outlineSphere.position.set(lm[0], lm[1], lm[2]);
                        scene.add(outlineSphere);
                        leftHandObjects.push(outlineSphere);
                    });
                }
                if (showCylinders) {
                    drawConnectionsCylinder(rotatedLeftHand, HAND_CONNECTIONS, LEFT_COLOR, leftHandLines);
                }
            }
            
            // Right Hand
            if (data.right_hand && data.right_hand[frameIndex] && showRightHand) {
                    const rotatedRightHand = data.right_hand[frameIndex].map(landmark => rotateLandmark(landmark, false));

                if (showSpheres) {
                    rotatedRightHand.forEach(lm => {
                        // ë©”ì¸ êµ¬
                        const geometry = new THREE.SphereGeometry(0.014, 12, 12);
                        const material = new THREE.MeshLambertMaterial({ 
                            color: RIGHT_COLOR,
                            emissive: RIGHT_COLOR,
                            emissiveIntensity: 0.1
                        });
                        const sphere = new THREE.Mesh(geometry, material);
                        sphere.position.set(lm[0], lm[1], lm[2]);
                        scene.add(sphere);
                        rightHandObjects.push(sphere);
                        
                        // ì™¸ê³½ì„  êµ¬
                        const outlineGeometry = new THREE.SphereGeometry(0.018, 12, 12);
                        const outlineMaterial = new THREE.MeshBasicMaterial({ 
                            color: 0x000000, 
                            transparent: true, 
                            opacity: 0.6,
                            side: THREE.BackSide
                        });
                        const outlineSphere = new THREE.Mesh(outlineGeometry, outlineMaterial);
                        outlineSphere.position.set(lm[0], lm[1], lm[2]);
                        scene.add(outlineSphere);
                        rightHandObjects.push(outlineSphere);
                    });
                }
                if (showCylinders) {
                    drawConnectionsCylinder(rotatedRightHand, HAND_CONNECTIONS, RIGHT_COLOR, rightHandLines);
                }
            }
            
            document.getElementById('current-frame').textContent = currentFrame;
            document.getElementById('frame-slider').value = currentFrame;
        }
        
        // ì”¬ í´ë¦¬ì–´
        function clearScene() {
            [...poseObjects, ...leftHandObjects, ...rightHandObjects].forEach(obj => {
                scene.remove(obj);
                if (obj.geometry) obj.geometry.dispose();
                if (obj.material) obj.material.dispose();
            });
            [...poseLines, ...leftHandLines, ...rightHandLines].forEach(line => {
                scene.remove(line);
                if (line.geometry) line.geometry.dispose();
                if (line.material) line.material.dispose();
            });
            poseObjects = []; leftHandObjects = []; rightHandObjects = [];
            poseLines = []; leftHandLines = []; rightHandLines = [];
        }
        
        // ì—°ê²°ì„  ê·¸ë¦¬ê¸°
        function drawConnectionsCylinder(landmarks, connections, color, lineArray) {
            connections.forEach(connection => {
                if (connection[0] < landmarks.length && connection[1] < landmarks.length) {
                    const start = landmarks[connection[0]];
                    const end = landmarks[connection[1]];
                    let is34 = false;
                    let ISright = false;

                    if(color == 0xd63031)
                        ISright = true;
                    else
                        ISright = false;
                    
                    if(connection[0] === 3 && connection[1] === 4
                        || connection[0] === 7 && connection[1] === 8
                        || connection[0] === 11 && connection[1] === 12
                        || connection[0] === 15 && connection[1] === 16
                        || connection[0] === 19 && connection[1] === 20
                    )
                        {
                            is34 = true;
                        }
                    const startVec = new THREE.Vector3(start[0], start[1], start[2]);
                    const endVec = new THREE.Vector3(end[0], end[1], end[2]);
                    const distance = startVec.distanceTo(endVec);
                    
                    // ë©”ì¸ ì›ê¸°ë‘¥ (ë” ì§„í•œ ìƒ‰ìƒ)
                    const geometry = new THREE.CylinderGeometry(0.008, 0.008, distance, 12);

                    if(is34)
                    {
                     if(ISright)
                    {
                        const material = new THREE.MeshLambertMaterial({ 
                        color: 0xffc4c4, 
                        transparent: true, 
                        opacity: 0.9,
                        emissive: color,
                        emissiveIntensity: 0.1
                    });
                    const cylinder = new THREE.Mesh(geometry, material);
                    cylinder.position.copy(startVec).add(endVec).multiplyScalar(0.5);
                    const up = new THREE.Vector3(0, 1, 0);
                    const quaternion = new THREE.Quaternion().setFromUnitVectors(up, new THREE.Vector3().subVectors(endVec, startVec).normalize());
                    cylinder.quaternion.copy(quaternion);
                    scene.add(cylinder);
                    lineArray.push(cylinder);

                                        const outlineGeometry = new THREE.CylinderGeometry(0.012, 0.012, distance, 12);
                    const outlineMaterial = new THREE.MeshBasicMaterial({ 
                        color: 0xffffff , 
                        transparent: true, 
                        opacity: 0.6,
                        side: THREE.BackSide
                    });
                    const outlineCylinder = new THREE.Mesh(outlineGeometry, outlineMaterial);
                    outlineCylinder.position.copy(cylinder.position);
                    outlineCylinder.quaternion.copy(cylinder.quaternion);
                    scene.add(outlineCylinder);
                    lineArray.push(outlineCylinder);
                    }   
                    else
                    {
                        const material = new THREE.MeshLambertMaterial({ 
                        color: 0xcffffc, 
                        transparent: true, 
                        opacity: 0.9,
                        emissive: color,
                        emissiveIntensity: 0.1
                    });
                    const cylinder = new THREE.Mesh(geometry, material);
                    cylinder.position.copy(startVec).add(endVec).multiplyScalar(0.5);
                    const up = new THREE.Vector3(0, 1, 0);
                    const quaternion = new THREE.Quaternion().setFromUnitVectors(up, new THREE.Vector3().subVectors(endVec, startVec).normalize());
                    cylinder.quaternion.copy(quaternion);
                    scene.add(cylinder);
                    lineArray.push(cylinder);

                                        const outlineGeometry = new THREE.CylinderGeometry(0.012, 0.012, distance, 12);
                    const outlineMaterial = new THREE.MeshBasicMaterial({ 
                        color: 0xffffff , 
                        transparent: true, 
                        opacity: 0.6,
                        side: THREE.BackSide
                    });
                    const outlineCylinder = new THREE.Mesh(outlineGeometry, outlineMaterial);
                    outlineCylinder.position.copy(cylinder.position);
                    outlineCylinder.quaternion.copy(cylinder.quaternion);
                    scene.add(outlineCylinder);
                    lineArray.push(outlineCylinder);
                    }
                        
                    }
                    else
                    {
                        const material = new THREE.MeshLambertMaterial({ 
                        color: color, 
                        transparent: true, 
                        opacity: 0.9,
                        emissive: color,
                        emissiveIntensity: 0.1
                    });
                                        const cylinder = new THREE.Mesh(geometry, material);
                    cylinder.position.copy(startVec).add(endVec).multiplyScalar(0.5);
                    const up = new THREE.Vector3(0, 1, 0);
                    const quaternion = new THREE.Quaternion().setFromUnitVectors(up, new THREE.Vector3().subVectors(endVec, startVec).normalize());
                    cylinder.quaternion.copy(quaternion);
                    scene.add(cylinder);
                    lineArray.push(cylinder);

                                        const outlineGeometry = new THREE.CylinderGeometry(0.012, 0.012, distance, 12);
                    const outlineMaterial = new THREE.MeshBasicMaterial({ 
                        color: 0xffffff , 
                        transparent: true, 
                        opacity: 0.6,
                        side: THREE.BackSide
                    });
                    const outlineCylinder = new THREE.Mesh(outlineGeometry, outlineMaterial);
                    outlineCylinder.position.copy(cylinder.position);
                    outlineCylinder.quaternion.copy(cylinder.quaternion);
                    scene.add(outlineCylinder);
                    lineArray.push(outlineCylinder);
                    }


                }
            });
        }
        
        // ì»¨íŠ¸ë¡¤ í•¨ìˆ˜ë“¤
        function previousFrame() {
            if (currentFrame > 0) {
                loadFrame(currentFrame - 1);
            }
        }
        
        function nextFrame() {
            if (data && currentFrame < data.pose.length - 1) {
                loadFrame(currentFrame + 1);
            }
        }
        
        function playAnimation() {
            if (isPlaying) {
                isPlaying = false;
                if (animationInterval) {
                    clearInterval(animationInterval);
                    animationInterval = null;
                }
                document.getElementById('play-btn').textContent = 'â–¶ ì¬ìƒ';
            } else {
                isPlaying = true;
                document.getElementById('play-btn').textContent = 'â¸ ì •ì§€';
                animationInterval = setInterval(() => {
                    if (data && currentFrame < data.pose.length - 1) {
                        loadFrame(currentFrame + 1);
                    } else {
                        loadFrame(0);
                    }
                }, 1000 / animationSpeed);
            }
        }
        
        function resetCamera() {
            camera.position.set(cameraInitPos.x, cameraInitPos.y, cameraInitPos.z);
            yaw = -10.3 * Math.PI / 180;
            pitch = 178.7 * Math.PI / 180;
            roll = 0 * Math.PI / 180;
            updateCameraDirection();
            logCameraState('ì¹´ë©”ë¼ ë¦¬ì…‹');
        }
        
        function sliderFrame(val) {
            loadFrame(parseInt(val));
        }
        
        function updateSpeed() {
            animationSpeed = parseInt(document.getElementById('speed').value);
            document.getElementById('speed-value').textContent = animationSpeed;
            if (isPlaying && animationInterval) {
                clearInterval(animationInterval);
                playAnimation();
            }
        }
        
        // ìœˆë„ìš° ë¦¬ì‚¬ì´ì¦ˆ ì²˜ë¦¬
        window.addEventListener('resize', () => {
            const canvas = document.getElementById('landmark-canvas');
            camera.aspect = canvas.offsetWidth / canvas.offsetHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(canvas.offsetWidth, canvas.offsetHeight);
        });

        // í¬ì¦ˆ ì˜¤í”„ì…‹ ì—…ë°ì´íŠ¸ í•¨ìˆ˜
function updatePoseOffset(axis, value) {
    value = parseFloat(value);
    poseOffset[axis] = value;
    document.getElementById(`pose-${axis}`).value = value.toFixed(3);
    if (currentFrame >= 0) {
        loadFrame(currentFrame);  // í˜„ì¬ í”„ë ˆì„ ë‹¤ì‹œ ë¡œë“œ
    }
}

// í¬ì¦ˆ ìŠ¤ì¼€ì¼ ì—…ë°ì´íŠ¸ í•¨ìˆ˜
function updatePoseScale(value) {
    poseScale = parseFloat(value);
    document.getElementById('pose-scale').value = poseScale.toFixed(3);
    if (currentFrame >= 0) {
        loadFrame(currentFrame);  // í˜„ì¬ í”„ë ˆì„ ë‹¤ì‹œ ë¡œë“œ
    }
}
    </script>
</body>
</html> 