<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prototype Viewer - ÎûúÎìúÎßàÌÅ¨ vs ÏõπÏ∫† ÎπÑÍµê</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            height: 100vh;
            overflow: hidden;
        }
        .header {
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            padding: 15px 30px;
            color: #333;
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
        }
        .header-content {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 30px;
        }
        .header-title {
            flex-shrink: 0;
        }
        .header-title h1 {
            font-size: 24px;
            font-weight: 300;
            margin-bottom: 5px;
            color: #2c3e50;
        }
        .header-title p {
            font-size: 14px;
            opacity: 0.7;
            color: #34495e;
            margin: 0;
        }
        .header-controls {
            display: flex;
            align-items: center;
            gap: 20px;
            flex-wrap: wrap;
        }
        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .control-group label {
            color: #2c3e50;
            font-size: 12px;
            font-weight: 500;
            white-space: nowrap;
        }
        .control-buttons {
            display: flex;
            gap: 5px;
        }
        .control-buttons button {
            padding: 6px 12px;
            font-size: 11px;
        }
        .control-toggles {
            display: flex;
            gap: 15px;
        }
        .control-toggles label {
            color: #2c3e50;
            font-size: 12px;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .main-container {
            display: flex;
            height: calc(100vh - 80px);
        }
        .left-panel, .right-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            position: relative;
        }
        .left-panel {
            background: rgba(255, 255, 255, 0.95);
            border-right: 2px solid rgba(0, 0, 0, 0.1);
        }
        .right-panel {
            background: rgba(255, 255, 255, 0.95);
        }
        .panel-title {
            background: rgba(52, 73, 94, 0.9);
            color: white;
            padding: 10px 20px;
            font-size: 16px;
            font-weight: 500;
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
        }
        .controls {
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
        }
        .control-row {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 10px;
        }
        .control-row:last-child { margin-bottom: 0; }
        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .control-group label {
            color: #2c3e50;
            font-size: 12px;
            min-width: 60px;
            font-weight: 500;
        }
        select, input[type="range"] {
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid rgba(0, 0, 0, 0.2);
            color: #2c3e50;
            padding: 5px 8px;
            border-radius: 4px;
            font-size: 12px;
        }
        select option {
            background: #fff;
            color: #2c3e50;
        }
        button {
            background: linear-gradient(45deg, #3498db, #2980b9);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s ease;
        }
        button:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.3);
        }
        button:active {
            transform: translateY(0);
        }
        .canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            background: #f8f9fa;
        }
        #landmark-canvas, #webcam-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        .webcam-container {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #f8f9fa;
            position: relative;
        }
        #webcam-video {
            max-width: 100%;
            max-height: 100%;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }
        #webcam-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            border-radius: 8px;
        }
        .webcam-overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.9);
            color: #2c3e50;
            padding: 10px 15px;
            border-radius: 6px;
            font-size: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        .status-indicator {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #e74c3c;
        }
        .status-indicator.active {
            background: #27ae60;
            box-shadow: 0 0 10px #27ae60;
        }
        .info-text {
            color: #7f8c8d;
            font-size: 11px;
            margin-top: 5px;
        }
        .legend {
            display: flex;
            gap: 15px;
            margin-top: 10px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
            color: #2c3e50;
            font-size: 11px;
        }
        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="header-content">
            <div class="header-title">
                <h1>Prototype Viewer</h1>
                <p>ÎûúÎìúÎßàÌÅ¨ Ïï†ÎãàÎ©îÏù¥ÏÖò vs Ïã§ÏãúÍ∞Ñ ÏõπÏ∫† ÎπÑÍµê</p>
            </div>
            <div class="header-controls">
                <div class="control-group">
                    <label>ÎπÑÎîîÏò§:</label>
                    <select id="video-select"></select>
                </div>
                <div class="control-group">
                    <label>ÌîÑÎ†àÏûÑ:</label>
                    <span id="current-frame">0</span>
                </div>
                <div class="control-buttons">
                    <button onclick="previousFrame()">‚óÄ</button>
                    <button onclick="playAnimation()" id="play-btn">‚ñ∂</button>
                    <button onclick="nextFrame()">‚ñ∂</button>
                    <button onclick="resetCamera()">üîÑ</button>
                </div>
                <div class="control-group">
                    <label>ÌîÑÎ†àÏûÑ:</label>
                    <input type="range" id="frame-slider" min="0" max="0" value="0" style="width: 120px;" oninput="sliderFrame(this.value)">
                </div>
                <div class="control-group">
                    <label>ÏÜçÎèÑ:</label>
                    <input type="range" id="speed" min="1" max="30" value="5" onchange="updateSpeed()" style="width: 80px;">
                    <span id="speed-value">5</span>
                </div>
                <div class="control-toggles">
                    <label><input type="checkbox" id="show-cylinders" checked> ÏõêÍ∏∞Îë•(ÏÑ†)</label>
                    <label><input type="checkbox" id="show-left-hand" checked> Ï¢åÏ∏° ÏÜê</label>
                    <label><input type="checkbox" id="show-right-hand" checked> Ïö∞Ï∏° ÏÜê</label>
                </div>
            </div>
        </div>
    </div>
    
    <div class="main-container">
        <!-- Ï¢åÏ∏° Ìå®ÎÑê: ÎûúÎìúÎßàÌÅ¨ Î∑∞Ïñ¥ (Ï†ÑÏ≤¥ Í≥µÍ∞Ñ) -->
        <div class="left-panel">
            <div class="panel-title">3D ÎûúÎìúÎßàÌÅ¨ Î∑∞Ïñ¥</div>
            <div class="canvas-container">
                <canvas id="landmark-canvas"></canvas>
            </div>
        </div>
        
        <!-- Ïö∞Ï∏° Ìå®ÎÑê: ÏõπÏ∫† + Ïª®Ìä∏Î°§ -->
        <div class="right-panel">
            <div class="panel-title">Ïã§ÏãúÍ∞Ñ ÏõπÏ∫†</div>
            
            <div class="webcam-container">
                <video id="webcam-video" autoplay muted playsinline></video>
                <canvas id="webcam-overlay" style="position: absolute; top: 0; left: 0; pointer-events: none;"></canvas>
                <div class="webcam-overlay">
                    <div>ÏõπÏ∫† Ïä§Ìä∏Î¶º</div>
                    <div id="webcam-status">Ïó∞Í≤∞ Ï§ë...</div>
                </div>
                <div class="status-indicator" id="webcam-indicator"></div>
            </div>
        </div>
    </div>

    <script>
        // ÎûúÎìúÎßàÌÅ¨ Î∑∞Ïñ¥ Í¥ÄÎ†® Î≥ÄÏàòÎì§
        let scene, camera, renderer;
        let poseObjects = [], leftHandObjects = [], rightHandObjects = [];
        let poseLines = [], leftHandLines = [], rightHandLines = [];
        let currentFrame = 0;
        let isPlaying = false;
        let animationSpeed = 5;
        let animationInterval;
        let allData = null;
        let data = null;
        
        // Ïπ¥Î©îÎùº Ïª®Ìä∏Î°§ Î≥ÄÏàò (ÌîåÎùºÏù¥/ÌîÑÎ¶¨ Î¨¥Î∏å)
        // Ï¥àÍ∏∞ Ïπ¥Î©îÎùº ÏÑ§Ï†ï:
        // - ÏúÑÏπò: (-0.388, 0.334, -0.655) - ÏÇ¨Ïö©Ïûê ÏßÄÏ†ï ÏúÑÏπò
        // - Yaw: -10.3ÎèÑ (Ï¢åÏö∞ ÌöåÏ†Ñ) - ÏÇ¨Ïö©Ïûê ÏßÄÏ†ï Í∞ÅÎèÑ
        // - Pitch: 178.7ÎèÑ (ÏÉÅÌïò ÌöåÏ†Ñ) - ÏÇ¨Ïö©Ïûê ÏßÄÏ†ï Í∞ÅÎèÑ
        // - Roll: 0ÎèÑ (ÏãúÏ†ê ÌöåÏ†Ñ) - ÏÇ¨Ïö©Ïûê ÏßÄÏ†ï Í∞ÅÎèÑ
        let cameraInitPos = { x: -0.388, y: 0.334, z: -0.655 };
        let cameraInitRot = { x: 0, y: 0, z: 0 };
        let isMouseDown = false;
        let lastMouseX = 0, lastMouseY = 0;
        let yaw = 0;
        let pitch = 0;
        let roll = 0;
        
        // ÏÉâÏÉÅ
        const POSE_COLOR = 0x00b894;
        const LEFT_COLOR = 0x0984e3;
        const RIGHT_COLOR = 0xd63031;
        
        // Ïó∞Í≤∞ Íµ¨Ï°∞
        const POSE_CONNECTIONS = [
            [0,1],[1,2],[2,3],[3,7],[0,4],[4,5],[5,6],[6,8],[9,10],[11,12],[11,13],[13,15],[15,17],[15,19],[15,21],[17,19],[12,14],[14,16],[16,18],[16,20],[16,22],[18,20],[11,23],[12,24],[23,24],[23,25],[24,26],[25,27],[26,28],[27,29],[28,30],[29,31],[30,32],[27,31],[28,32]
        ];
        const HAND_CONNECTIONS = [
            [0,1],[1,2],[2,3],[3,4],
            [0,5],[5,6],[6,7],[7,8],
            [0,9],[9,10],[10,11],[11,12],
            [0,13],[13,14],[14,15],[15,16],
            [0,17],[17,18],[18,19],[19,20],
            [5,9],[9,13],[13,17],[5,17]
        ];
        
        // ÏõπÏ∫† Í¥ÄÎ†® Î≥ÄÏàò
        let webcamStream = null;
        let webcamVideo = null;
        
        // Ï¥àÍ∏∞Ìôî
        window.onload = function() {
            initLandmarkViewer();
            initWebcam();
        };
        
        // ÎûúÎìúÎßàÌÅ¨ Î∑∞Ïñ¥ Ï¥àÍ∏∞Ìôî
        function initLandmarkViewer() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf8f9fa);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / 2 / window.innerHeight, 0.001, 1000);
            camera.position.set(cameraInitPos.x, cameraInitPos.y, cameraInitPos.z);
            camera.rotation.set(cameraInitRot.x, cameraInitRot.y, cameraInitRot.z);
            yaw = -10.3 * Math.PI / 180;
            pitch = 178.7 * Math.PI / 180;
            roll = 0 * Math.PI / 180;
            updateCameraDirection();
            
            const canvas = document.getElementById('landmark-canvas');
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true, alpha: true });
            renderer.setSize(canvas.offsetWidth, canvas.offsetHeight);
            renderer.setClearColor(0xf8f9fa, 1);
            
            const ambientLight = new THREE.AmbientLight(0x404040, 0.8);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);
            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight2.position.set(-1, 1, -1);
            scene.add(directionalLight2);
            
            // Îç∞Ïù¥ÌÑ∞ Î°úÎìú
            loadLandmarkData();
            
            // Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà
            setupEventListeners();
            
            animate();
            
            // Ï¥àÍ∏∞ Ïπ¥Î©îÎùº ÏÉÅÌÉú Î°úÍ∑∏
            logCameraState('Ï¥àÍ∏∞Ìôî');
        }
        
        // ÏõπÏ∫† Ï¥àÍ∏∞Ìôî
        async function initWebcam() {
            try {
                console.log('ÏõπÏ∫† Ï¥àÍ∏∞Ìôî ÏãúÏûë...');
                webcamVideo = document.getElementById('webcam-video');
                webcamStream = await navigator.mediaDevices.getUserMedia({ 
                    video: { 
                        width: { ideal: 640 },
                        height: { ideal: 480 }
                    }, 
                    audio: false 
                });
                webcamVideo.srcObject = webcamStream;
                
                // ÎπÑÎîîÏò§ Î°úÎìú ÏôÑÎ£å ÎåÄÍ∏∞
                await new Promise((resolve) => {
                    webcamVideo.onloadedmetadata = () => {
                        console.log('ÏõπÏ∫† ÎπÑÎîîÏò§ Î°úÎìú ÏôÑÎ£å:', webcamVideo.videoWidth, 'x', webcamVideo.videoHeight);
                        resolve();
                    };
                });
                
                webcamVideo.play();
                console.log('ÏõπÏ∫† Ïû¨ÏÉù ÏãúÏûë');
                
                document.getElementById('webcam-status').textContent = 'Ïó∞Í≤∞Îê®';
                document.getElementById('webcam-indicator').classList.add('active');
                
                // MediaPipe Tasks Vision Ï¥àÍ∏∞Ìôî
                await initMediaPipeHands();
            } catch (error) {
                console.error('ÏõπÏ∫† Ï†ëÍ∑º Ïã§Ìå®:', error);
                document.getElementById('webcam-status').textContent = 'Ï†ëÍ∑º Ïã§Ìå®';
                document.getElementById('webcam-video').style.display = 'none';
            }
        }
        
        // MediaPipe Tasks Vision Ï¥àÍ∏∞Ìôî
        let handLandmarker = null;
        let webcamOverlay = null;
        let webcamCtx = null;
        
        async function initMediaPipeHands() {
            try {
                console.log('MediaPipe Tasks Vision Î™®Îìà Î°úÎìú ÏãúÏûë...');
                // MediaPipe Tasks Vision Î™®Îìà Î°úÎìú
                const { HandLandmarker, FilesetResolver } = await import("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0");
                console.log('MediaPipe Î™®Îìà Î°úÎìú ÏôÑÎ£å');
                
                console.log('FilesetResolver Ï¥àÍ∏∞Ìôî...');
                const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm");
                console.log('FilesetResolver Ï¥àÍ∏∞Ìôî ÏôÑÎ£å');
                
                console.log('HandLandmarker ÏÉùÏÑ± ÏãúÏûë...');
                handLandmarker = await HandLandmarker.createFromOptions(vision, {
                    baseOptions: {
                        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                        delegate: "GPU"
                    },
                    runningMode: "VIDEO",
                    numHands: 2
                });
                console.log('HandLandmarker ÏÉùÏÑ± ÏôÑÎ£å');
                
                // ÏõπÏ∫† Ïò§Î≤ÑÎ†àÏù¥ Ï∫îÎ≤ÑÏä§ ÏÑ§Ï†ï
                webcamOverlay = document.getElementById('webcam-overlay');
                webcamCtx = webcamOverlay.getContext('2d');
                console.log('ÏõπÏ∫† Ïò§Î≤ÑÎ†àÏù¥ Ï∫îÎ≤ÑÏä§ ÏÑ§Ï†ï ÏôÑÎ£å');
                
                // ÎπÑÎîîÏò§ ÌÅ¨Í∏∞ ÏÑ§Ï†ï
                console.log('ÎπÑÎîîÏò§ ÌÅ¨Í∏∞ ÏÑ§Ï†ï:', webcamVideo.videoWidth, 'x', webcamVideo.videoHeight);
                webcamOverlay.width = webcamVideo.videoWidth;
                webcamOverlay.height = webcamVideo.videoHeight;
                
                document.getElementById('webcam-status').textContent = 'ÏÜê Í∞êÏßÄ ÌôúÏÑ±Ìôî';
                console.log('MediaPipe Hands Ï¥àÍ∏∞Ìôî ÏôÑÎ£å');
                
                // Ï¶âÏãú ÏÜê Í∞êÏßÄ ÏãúÏûë
                console.log('ÏÜê Í∞êÏßÄ Ï¶âÏãú ÏãúÏûë...');
                setTimeout(() => {
                    startHandDetection();
                }, 100);
                
            } catch (error) {
                console.error('MediaPipe Hands Ï¥àÍ∏∞Ìôî Ïã§Ìå®:', error);
                document.getElementById('webcam-status').textContent = 'ÏÜê Í∞êÏßÄ Ï¥àÍ∏∞Ìôî Ïã§Ìå®';
            }
        }
        
        function startHandDetection() {
            console.log('=== ÏÜê Í∞êÏßÄ ÏãúÏûë Ìï®Ïàò Ìò∏Ï∂ú ===');
            console.log('handLandmarker Ï°¥Ïû¨:', !!handLandmarker);
            console.log('webcamVideo Ï°¥Ïû¨:', !!webcamVideo);
            console.log('webcamVideo readyState:', webcamVideo ? webcamVideo.readyState : 'N/A');
            console.log('webcamVideo videoWidth:', webcamVideo ? webcamVideo.videoWidth : 'N/A');
            console.log('webcamVideo videoHeight:', webcamVideo ? webcamVideo.videoHeight : 'N/A');
            console.log('webcamOverlay Ï°¥Ïû¨:', !!webcamOverlay);
            console.log('webcamCtx Ï°¥Ïû¨:', !!webcamCtx);
            
            // Ï°∞Í±¥ ÌôïÏù∏
            const hasHandLandmarker = !!handLandmarker;
            const hasVideo = !!webcamVideo;
            const videoReady = hasVideo && webcamVideo.readyState >= 2;
            const hasOverlay = !!webcamOverlay && !!webcamCtx;
            
            console.log('Ï°∞Í±¥ ÌôïÏù∏:', {
                hasHandLandmarker,
                hasVideo,
                videoReady,
                hasOverlay
            });
            
            if (hasHandLandmarker && hasVideo && hasOverlay) {
                console.log('Î™®Îì† Ï°∞Í±¥ Ï∂©Ï°±! ÏÜê Í∞êÏßÄ Î£®ÌîÑ ÏãúÏûë');
                detectHands();
            } else {
                console.log('Ï°∞Í±¥ Î∂àÏ∂©Ï°±, 1Ï¥à ÌõÑ Ïû¨ÏãúÎèÑ...');
                // Ï°∞Í±¥Ïù¥ Ï∂©Ï°±ÎêòÏßÄ ÏïäÏúºÎ©¥ 1Ï¥à ÌõÑ Îã§Ïãú ÏãúÎèÑ
                setTimeout(startHandDetection, 1000);
            }
        }
        
        async function detectHands() {
            try {
                console.log('ÏÜê Í∞êÏßÄ Ïã§Ìñâ Ï§ë... (ÌîÑÎ†àÏûÑ:', Date.now(), ')');
                
                // ÎπÑÎîîÏò§Í∞Ä Ï§ÄÎπÑÎêòÏßÄ ÏïäÏïòÏúºÎ©¥ ÎåÄÍ∏∞
                if (webcamVideo.readyState < 2) {
                    console.log('ÎπÑÎîîÏò§Í∞Ä ÏïÑÏßÅ Ï§ÄÎπÑÎêòÏßÄ ÏïäÏùå, Îã§Ïùå ÌîÑÎ†àÏûÑÏóêÏÑú Ïû¨ÏãúÎèÑ');
                    requestAnimationFrame(detectHands);
                    return;
                }
                
                const results = await handLandmarker.detectForVideo(webcamVideo, performance.now());
                console.log('ÏÜê Í∞êÏßÄ Í≤∞Í≥º:', results);
                
                // Ïò§Î≤ÑÎ†àÏù¥ Ï∫îÎ≤ÑÏä§ ÌÅ¥Î¶¨Ïñ¥
                webcamCtx.clearRect(0, 0, webcamOverlay.width, webcamOverlay.height);
                
                // ÏÜê ÎûúÎìúÎßàÌÅ¨ Í∑∏Î¶¨Í∏∞
                if (results && results.landmarks && results.landmarks.length > 0) {
                    console.log('Í∞êÏßÄÎêú ÏÜê Í∞úÏàò:', results.landmarks.length);
                    console.log('ÏÜê Íµ¨Î∂Ñ Ï†ïÎ≥¥:', results.handedness);
                    
                    results.landmarks.forEach((landmarks, handIndex) => {
                        // handedness Ï†ïÎ≥¥Î•º ÏÇ¨Ïö©ÌïòÏó¨ Ïã§Ï†ú ÏôºÏÜê/Ïò§Î•∏ÏÜê Íµ¨Î∂Ñ
                        const handedness = results.handedness && results.handedness[handIndex] ? results.handedness[handIndex][0] : null;
                        let color, handType;
                        
                        if (handedness) {
                            if (handedness.categoryName === 'Left') {
                                color = '#00FF00'; // ÏôºÏÜê: Ï¥àÎ°ùÏÉâ
                                handType = 'ÏôºÏÜê';
                            } else if (handedness.categoryName === 'Right') {
                                color = '#FF0000'; // Ïò§Î•∏ÏÜê: Îπ®Í∞ÑÏÉâ
                                handType = 'Ïò§Î•∏ÏÜê';
                            } else {
                                color = '#FFFF00'; // Ïïå Ïàò ÏóÜÏùå: ÎÖ∏ÎûÄÏÉâ
                                handType = 'Ïïå Ïàò ÏóÜÏùå';
                            }
                        } else {
                            // handedness Ï†ïÎ≥¥Í∞Ä ÏóÜÏúºÎ©¥ Í∏∞Ï°¥ Î∞©Ïãù ÏÇ¨Ïö©
                            color = handIndex === 0 ? '#00FF00' : '#FF0000';
                            handType = handIndex === 0 ? 'Ï≤´ Î≤àÏß∏ ÏÜê' : 'Îëê Î≤àÏß∏ ÏÜê';
                        }
                        
                        console.log(`ÏÜê ${handIndex + 1}: ${handType} (${color})`);
                        drawHandLandmarks(landmarks, color);
                    });
                } else {
                    console.log('Í∞êÏßÄÎêú ÏÜêÏù¥ ÏóÜÏäµÎãàÎã§');
                }
                
                // Îã§Ïùå ÌîÑÎ†àÏûÑ Ï≤òÎ¶¨
                requestAnimationFrame(detectHands);
            } catch (error) {
                console.error('ÏÜê Í∞êÏßÄ Ïò§Î•ò:', error);
                // Ïò§Î•ò Î∞úÏÉù ÏãúÏóêÎèÑ Í≥ÑÏÜç ÏãúÎèÑ
                setTimeout(() => {
                    requestAnimationFrame(detectHands);
                }, 100);
            }
        }
        
        function drawHandLandmarks(landmarks, color) {
            // ÏÜê Ïó∞Í≤∞ÏÑ† Ï†ïÏùò
            const HAND_CONNECTIONS = [
                [0,1],[1,2],[2,3],[3,4],
                [0,5],[5,6],[6,7],[7,8],
                [0,9],[9,10],[10,11],[11,12],
                [0,13],[13,14],[14,15],[15,16],
                [0,17],[17,18],[18,19],[19,20],
                [5,9],[9,13],[13,17],[5,17]
            ];
            
            // Ïó∞Í≤∞ÏÑ† Í∑∏Î¶¨Í∏∞
            HAND_CONNECTIONS.forEach(([start, end]) => {
                const startPoint = landmarks[start];
                const endPoint = landmarks[end];
                
                if (startPoint && endPoint) {
                    const startX = startPoint.x * webcamOverlay.width;
                    const startY = startPoint.y * webcamOverlay.height;
                    const endX = endPoint.x * webcamOverlay.width;
                    const endY = endPoint.y * webcamOverlay.height;
                    
                    webcamCtx.strokeStyle = color;
                    webcamCtx.lineWidth = 2;
                    webcamCtx.beginPath();
                    webcamCtx.moveTo(startX, startY);
                    webcamCtx.lineTo(endX, endY);
                    webcamCtx.stroke();
                }
            });
            
            // ÎûúÎìúÎßàÌÅ¨ Ï†ê Í∑∏Î¶¨Í∏∞
            landmarks.forEach(landmark => {
                const x = landmark.x * webcamOverlay.width;
                const y = landmark.y * webcamOverlay.height;
                
                webcamCtx.fillStyle = color;
                webcamCtx.beginPath();
                webcamCtx.arc(x, y, 3, 0, 2 * Math.PI);
                webcamCtx.fill();
            });
        }
        
        // ÎûúÎìúÎßàÌÅ¨ Îç∞Ïù¥ÌÑ∞ Î°úÎìú
        function loadLandmarkData() {
            // file_list.jsonÏóêÏÑú ÌååÏùº Î™©Î°ù Î°úÎìú
            fetch('result/file_list.json')
                .then(response => {
                    if (!response.ok) {
                        throw new Error('file_list.json Î°úÎìú Ïã§Ìå®');
                    }
                    return response.json();
                })
                .then(fileList => {
                    const jsonFiles = fileList.landmark_files || [];
                    console.log('ÌååÏùº Î™©Î°ùÏóêÏÑú Î∞úÍ≤¨Îêú ÌååÏùºÎì§:', jsonFiles);
                    
                    if (jsonFiles.length === 0) {
                        throw new Error('file_list.jsonÏóê ÌååÏùºÏù¥ ÏóÜÏäµÎãàÎã§.');
                    }
                    
                    // Í∞Å ÌååÏùºÏùÑ Î°úÎìú
                    const loadPromises = jsonFiles.map(filename => 
                        fetch(`result/${filename}`)
                            .then(response => {
                                if (!response.ok) {
                                    throw new Error(`HTTP ${response.status}`);
                                }
                                return response.json();
                            })
                            .then(data => ({ filename, data }))
                            .catch(error => {
                                console.warn(`ÌååÏùº Î°úÎìú Ïã§Ìå®: ${filename} - ${error.message}`);
                                return null;
                            })
                    );
                    
                    return Promise.all(loadPromises);
                })
                .then(results => {
                    const validResults = results.filter(result => result !== null);
                    
                    if (validResults.length === 0) {
                        throw new Error('Î°úÎìú Í∞ÄÎä•Ìïú JSON ÌååÏùºÏù¥ ÏóÜÏäµÎãàÎã§.');
                    }
                    
                    console.log('ÏÑ±Í≥µÏ†ÅÏúºÎ°ú Î°úÎìúÎêú ÌååÏùºÎì§:', validResults.map(r => r.filename));
                    return validResults;
                })
                .then(results => {
                    // allDataÎ•º ÌååÏùºÎ™ÖÏùÑ ÌÇ§Î°ú ÌïòÎäî Í∞ùÏ≤¥Î°ú Íµ¨ÏÑ±
                    allData = {};
                    results.forEach(({ filename, data }) => {
                        const baseName = filename.replace('_landmarks.json', '');
                        allData[baseName] = data;
                    });
                    
                    const select = document.getElementById('video-select');
                    
                    // ÌååÏùº ÏÑ†ÌÉù ÏòµÏÖò ÏÉùÏÑ±
                    Object.keys(allData).forEach(filename => {
                        const opt = document.createElement('option');
                        opt.value = filename;
                        opt.textContent = filename;
                        select.appendChild(opt);
                    });
                    
                    select.onchange = function() {
                        data = allData[select.value];
                        document.getElementById('frame-slider').max = data.pose.length - 1;
                        loadFrame(0);
                    };
                    
                    select.value = Object.keys(allData)[0];
                    select.onchange();
                })
                .catch(error => {
                    console.error('Îç∞Ïù¥ÌÑ∞ Î°úÎìú Ïã§Ìå®:', error);
                    document.querySelector('.left-panel').innerHTML = `
                        <div style="color: white; padding: 20px; text-align: center;">
                            <h3>Îç∞Ïù¥ÌÑ∞ Î°úÎìú Ïã§Ìå®</h3>
                            <p>${error.message}</p>
                            <p>result ÎîîÎ†âÌÜ†Î¶¨Ïóê JSON ÌååÏùºÏù¥ ÏûàÎäîÏßÄ ÌôïÏù∏Ìï¥Ï£ºÏÑ∏Ïöî.</p>
                        </div>
                    `;
                });
        }
        
        // Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà ÏÑ§Ï†ï
        function setupEventListeners() {
            // ÌÇ§Î≥¥Îìú Ïª®Ìä∏Î°§ (ÏãúÏ†ê Ïù¥Îèô ÎπÑÌôúÏÑ±Ìôî)
            // document.addEventListener('keydown', handleKeyDown);
            
            // ÎßàÏö∞Ïä§ Ïª®Ìä∏Î°§ (ÏãúÏ†ê Ïù¥Îèô ÎπÑÌôúÏÑ±Ìôî)
            // const canvas = document.getElementById('landmark-canvas');
            // canvas.addEventListener('mousedown', handleMouseDown);
            // canvas.addEventListener('mousemove', handleMouseMove);
            // canvas.addEventListener('mouseup', handleMouseUp);
            // canvas.addEventListener('mouseleave', handleMouseUp);
            // canvas.addEventListener('wheel', handleWheel);
            
            // Ï≤¥ÌÅ¨Î∞ïÏä§ Ïù¥Î≤§Ìä∏ (Íµ¨ ÏòµÏÖòÍ≥º Î™∏ ÏòµÏÖò Ï†úÍ±∞)
            document.getElementById('show-cylinders').addEventListener('change', () => loadFrame(currentFrame));
            document.getElementById('show-left-hand').addEventListener('change', () => loadFrame(currentFrame));
            document.getElementById('show-right-hand').addEventListener('change', () => loadFrame(currentFrame));
        }
        
        // Ïï†ÎãàÎ©îÏù¥ÏÖò Î£®ÌîÑ
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        
        // Ïπ¥Î©îÎùº Î∞©Ìñ• ÏóÖÎç∞Ïù¥Ìä∏
        function updateCameraDirection() {
            camera.rotation.order = 'YXZ';
            camera.rotation.y = yaw;
            camera.rotation.x = pitch;
            camera.rotation.z = roll;
        }
        
        // Ïπ¥Î©îÎùº ÏÉÅÌÉú Î°úÍ∑∏ Ï∂úÎ†•
        function logCameraState(action) {
            const yawDegrees = (yaw * 180 / Math.PI).toFixed(1);
            const pitchDegrees = (pitch * 180 / Math.PI).toFixed(1);
            const rollDegrees = (roll * 180 / Math.PI).toFixed(1);
            console.log(`[${action}] Ïπ¥Î©îÎùº ÏÉÅÌÉú:`, {
                ÏúÑÏπò: {
                    x: camera.position.x.toFixed(3),
                    y: camera.position.y.toFixed(3),
                    z: camera.position.z.toFixed(3)
                },
                Í∞ÅÎèÑ: {
                    yaw: yawDegrees + '¬∞',
                    pitch: pitchDegrees + '¬∞',
                    roll: rollDegrees + '¬∞'
                }
            });
        }
        
        // ÌÇ§Î≥¥Îìú Ïù¥Î≤§Ìä∏ Ï≤òÎ¶¨
        function handleKeyDown(e) {
            const moveSpeed = 0.1;
            const rotateSpeed = 0.1;
            let forward = new THREE.Vector3();
            let right = new THREE.Vector3();
            let up = new THREE.Vector3(0, 1, 0);
            camera.getWorldDirection(forward);
            right.crossVectors(forward, up).normalize();
            
            let moved = false;
            switch(e.key.toLowerCase()) {
                case 'w':
                    camera.position.add(forward.clone().multiplyScalar(moveSpeed));
                    moved = true;
                    break;
                case 's':
                    camera.position.add(forward.clone().multiplyScalar(-moveSpeed));
                    moved = true;
                    break;
                case 'a':
                    camera.position.add(right.clone().multiplyScalar(-moveSpeed));
                    moved = true;
                    break;
                case 'd':
                    camera.position.add(right.clone().multiplyScalar(moveSpeed));
                    moved = true;
                    break;
                case 'q':
                    camera.position.y += moveSpeed;
                    moved = true;
                    break;
                case 'e':
                    camera.position.y -= moveSpeed;
                    moved = true;
                    break;
                case 'z':
                    roll -= rotateSpeed;
                    updateCameraDirection();
                    moved = true;
                    break;
                case 'c':
                    roll += rotateSpeed;
                    updateCameraDirection();
                    moved = true;
                    break;
                case 'r':
                    resetCamera();
                    return; // resetCameraÏóêÏÑú Î°úÍ∑∏ Ï∂úÎ†•
            }
            
            if (moved) {
                logCameraState('ÌÇ§Î≥¥Îìú Ïù¥Îèô');
            }
        }
        
        // ÎßàÏö∞Ïä§ Ïù¥Î≤§Ìä∏ Ï≤òÎ¶¨
        function handleMouseDown(e) {
            isMouseDown = true;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
        }
        
        function handleMouseMove(e) {
            if (!isMouseDown) return;
            const deltaX = e.clientX - lastMouseX;
            const deltaY = e.clientY - lastMouseY;
            const rotateSpeed = 0.005;
            yaw -= deltaX * rotateSpeed;
            pitch -= deltaY * rotateSpeed;
            updateCameraDirection();
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
            
            logCameraState('ÎßàÏö∞Ïä§ ÌöåÏ†Ñ');
        }
        
        function handleMouseUp() {
            isMouseDown = false;
        }
        
        function handleWheel(e) {
            e.preventDefault();
            const moveSpeed = 0.2;
            let forward = new THREE.Vector3();
            camera.getWorldDirection(forward);
            camera.position.add(forward.clone().multiplyScalar(-e.deltaY * moveSpeed * 0.01));
            
            logCameraState('Ìú† Ï§å');
        }
        
        // ÌîÑÎ†àÏûÑ Î°úÎìú
        function loadFrame(frameIndex) {
            if (!data) return;
            currentFrame = frameIndex;
            clearScene();
            
            const showSpheres = false; // Íµ¨ ÏòµÏÖò ÎπÑÌôúÏÑ±Ìôî
            const showCylinders = document.getElementById('show-cylinders').checked;
            const showPose = false; // Î™∏ ÏòµÏÖò ÎπÑÌôúÏÑ±Ìôî
            const showLeftHand = document.getElementById('show-left-hand').checked;
            const showRightHand = document.getElementById('show-right-hand').checked;
            
            // ÎûúÎìúÎßàÌÅ¨ ÌöåÏ†Ñ Ìï®Ïàò (YÏ∂ï Ï§ëÏã¨ ÏãúÍ≥ÑÎ∞©Ìñ• 180ÎèÑ)
            function rotateLandmark(lm) {
                return [-lm[0], lm[1], -lm[2]]; // xÏôÄ z Ï¢åÌëú Î∞òÏ†Ñ
            }
            
            // Pose
            if (data.pose && data.pose[frameIndex] && showPose) {
                const rotatedPose = data.pose[frameIndex].map(rotateLandmark);
                if (showSpheres) {
                    rotatedPose.forEach(lm => {
                        // Î©îÏù∏ Íµ¨
                        const geometry = new THREE.SphereGeometry(0.012, 12, 12);
                        const material = new THREE.MeshLambertMaterial({ 
                            color: POSE_COLOR,
                            emissive: POSE_COLOR,
                            emissiveIntensity: 0.1
                        });
                        const sphere = new THREE.Mesh(geometry, material);
                        sphere.position.set(lm[0], lm[1], lm[2]);
                        scene.add(sphere);
                        poseObjects.push(sphere);
                        
                        // Ïô∏Í≥ΩÏÑ† Íµ¨
                        const outlineGeometry = new THREE.SphereGeometry(0.016, 12, 12);
                        const outlineMaterial = new THREE.MeshBasicMaterial({ 
                            color: 0x000000, 
                            transparent: true, 
                            opacity: 0.6,
                            side: THREE.BackSide
                        });
                        const outlineSphere = new THREE.Mesh(outlineGeometry, outlineMaterial);
                        outlineSphere.position.set(lm[0], lm[1], lm[2]);
                        scene.add(outlineSphere);
                        poseObjects.push(outlineSphere);
                    });
                }
                if (showCylinders) {
                    drawConnectionsCylinder(rotatedPose, POSE_CONNECTIONS, POSE_COLOR, poseLines);
                }
            }
            
            // Left Hand
            if (data.left_hand && data.left_hand[frameIndex] && showLeftHand) {
                const rotatedLeftHand = data.left_hand[frameIndex].map(rotateLandmark);
                if (showSpheres) {
                    rotatedLeftHand.forEach(lm => {
                        // Î©îÏù∏ Íµ¨
                        const geometry = new THREE.SphereGeometry(0.014, 12, 12);
                        const material = new THREE.MeshLambertMaterial({ 
                            color: LEFT_COLOR,
                            emissive: LEFT_COLOR,
                            emissiveIntensity: 0.1
                        });
                        const sphere = new THREE.Mesh(geometry, material);
                        sphere.position.set(lm[0], lm[1], lm[2]);
                        scene.add(sphere);
                        leftHandObjects.push(sphere);
                        
                        // Ïô∏Í≥ΩÏÑ† Íµ¨
                        const outlineGeometry = new THREE.SphereGeometry(0.018, 12, 12);
                        const outlineMaterial = new THREE.MeshBasicMaterial({ 
                            color: 0x000000, 
                            transparent: true, 
                            opacity: 0.6,
                            side: THREE.BackSide
                        });
                        const outlineSphere = new THREE.Mesh(outlineGeometry, outlineMaterial);
                        outlineSphere.position.set(lm[0], lm[1], lm[2]);
                        scene.add(outlineSphere);
                        leftHandObjects.push(outlineSphere);
                    });
                }
                if (showCylinders) {
                    drawConnectionsCylinder(rotatedLeftHand, HAND_CONNECTIONS, LEFT_COLOR, leftHandLines);
                }
            }
            
            // Right Hand
            if (data.right_hand && data.right_hand[frameIndex] && showRightHand) {
                const rotatedRightHand = data.right_hand[frameIndex].map(rotateLandmark);
                if (showSpheres) {
                    rotatedRightHand.forEach(lm => {
                        // Î©îÏù∏ Íµ¨
                        const geometry = new THREE.SphereGeometry(0.014, 12, 12);
                        const material = new THREE.MeshLambertMaterial({ 
                            color: RIGHT_COLOR,
                            emissive: RIGHT_COLOR,
                            emissiveIntensity: 0.1
                        });
                        const sphere = new THREE.Mesh(geometry, material);
                        sphere.position.set(lm[0], lm[1], lm[2]);
                        scene.add(sphere);
                        rightHandObjects.push(sphere);
                        
                        // Ïô∏Í≥ΩÏÑ† Íµ¨
                        const outlineGeometry = new THREE.SphereGeometry(0.018, 12, 12);
                        const outlineMaterial = new THREE.MeshBasicMaterial({ 
                            color: 0x000000, 
                            transparent: true, 
                            opacity: 0.6,
                            side: THREE.BackSide
                        });
                        const outlineSphere = new THREE.Mesh(outlineGeometry, outlineMaterial);
                        outlineSphere.position.set(lm[0], lm[1], lm[2]);
                        scene.add(outlineSphere);
                        rightHandObjects.push(outlineSphere);
                    });
                }
                if (showCylinders) {
                    drawConnectionsCylinder(rotatedRightHand, HAND_CONNECTIONS, RIGHT_COLOR, rightHandLines);
                }
            }
            
            document.getElementById('current-frame').textContent = currentFrame;
            document.getElementById('frame-slider').value = currentFrame;
        }
        
        // Ïî¨ ÌÅ¥Î¶¨Ïñ¥
        function clearScene() {
            [...poseObjects, ...leftHandObjects, ...rightHandObjects].forEach(obj => {
                scene.remove(obj);
                if (obj.geometry) obj.geometry.dispose();
                if (obj.material) obj.material.dispose();
            });
            [...poseLines, ...leftHandLines, ...rightHandLines].forEach(line => {
                scene.remove(line);
                if (line.geometry) line.geometry.dispose();
                if (line.material) line.material.dispose();
            });
            poseObjects = []; leftHandObjects = []; rightHandObjects = [];
            poseLines = []; leftHandLines = []; rightHandLines = [];
        }
        
        // Ïó∞Í≤∞ÏÑ† Í∑∏Î¶¨Í∏∞
        function drawConnectionsCylinder(landmarks, connections, color, lineArray) {
            connections.forEach(connection => {
                if (connection[0] < landmarks.length && connection[1] < landmarks.length) {
                    const start = landmarks[connection[0]];
                    const end = landmarks[connection[1]];
                    const startVec = new THREE.Vector3(start[0], start[1], start[2]);
                    const endVec = new THREE.Vector3(end[0], end[1], end[2]);
                    const distance = startVec.distanceTo(endVec);
                    
                    // Î©îÏù∏ ÏõêÍ∏∞Îë• (Îçî ÏßÑÌïú ÏÉâÏÉÅ)
                    const geometry = new THREE.CylinderGeometry(0.008, 0.008, distance, 12);
                    const material = new THREE.MeshLambertMaterial({ 
                        color: color, 
                        transparent: true, 
                        opacity: 0.9,
                        emissive: color,
                        emissiveIntensity: 0.1
                    });
                    const cylinder = new THREE.Mesh(geometry, material);
                    cylinder.position.copy(startVec).add(endVec).multiplyScalar(0.5);
                    const up = new THREE.Vector3(0, 1, 0);
                    const quaternion = new THREE.Quaternion().setFromUnitVectors(up, new THREE.Vector3().subVectors(endVec, startVec).normalize());
                    cylinder.quaternion.copy(quaternion);
                    scene.add(cylinder);
                    lineArray.push(cylinder);
                    
                    // Ïô∏Í≥ΩÏÑ† ÏõêÍ∏∞Îë• (Îçî ÌÅ∞ Î∞òÏßÄÎ¶Ñ, Ïñ¥ÎëêÏö¥ ÏÉâÏÉÅ)
                    const outlineGeometry = new THREE.CylinderGeometry(0.012, 0.012, distance, 12);
                    const outlineMaterial = new THREE.MeshBasicMaterial({ 
                        color: 0x000000, 
                        transparent: true, 
                        opacity: 0.6,
                        side: THREE.BackSide
                    });
                    const outlineCylinder = new THREE.Mesh(outlineGeometry, outlineMaterial);
                    outlineCylinder.position.copy(cylinder.position);
                    outlineCylinder.quaternion.copy(cylinder.quaternion);
                    scene.add(outlineCylinder);
                    lineArray.push(outlineCylinder);
                }
            });
        }
        
        // Ïª®Ìä∏Î°§ Ìï®ÏàòÎì§
        function previousFrame() {
            if (currentFrame > 0) {
                loadFrame(currentFrame - 1);
            }
        }
        
        function nextFrame() {
            if (data && currentFrame < data.pose.length - 1) {
                loadFrame(currentFrame + 1);
            }
        }
        
        function playAnimation() {
            if (isPlaying) {
                isPlaying = false;
                if (animationInterval) {
                    clearInterval(animationInterval);
                    animationInterval = null;
                }
                document.getElementById('play-btn').textContent = '‚ñ∂ Ïû¨ÏÉù';
            } else {
                isPlaying = true;
                document.getElementById('play-btn').textContent = '‚è∏ Ï†ïÏßÄ';
                animationInterval = setInterval(() => {
                    if (data && currentFrame < data.pose.length - 1) {
                        loadFrame(currentFrame + 1);
                    } else {
                        loadFrame(0);
                    }
                }, 1000 / animationSpeed);
            }
        }
        
        function resetCamera() {
            camera.position.set(cameraInitPos.x, cameraInitPos.y, cameraInitPos.z);
            yaw = -10.3 * Math.PI / 180;
            pitch = 178.7 * Math.PI / 180;
            roll = 0 * Math.PI / 180;
            updateCameraDirection();
            logCameraState('Ïπ¥Î©îÎùº Î¶¨ÏÖã');
        }
        
        function sliderFrame(val) {
            loadFrame(parseInt(val));
        }
        
        function updateSpeed() {
            animationSpeed = parseInt(document.getElementById('speed').value);
            document.getElementById('speed-value').textContent = animationSpeed;
            if (isPlaying && animationInterval) {
                clearInterval(animationInterval);
                playAnimation();
            }
        }
        
        // ÏúàÎèÑÏö∞ Î¶¨ÏÇ¨Ïù¥Ï¶à Ï≤òÎ¶¨
        window.addEventListener('resize', () => {
            const canvas = document.getElementById('landmark-canvas');
            camera.aspect = canvas.offsetWidth / canvas.offsetHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(canvas.offsetWidth, canvas.offsetHeight);
        });
    </script>
</body>
</html> 