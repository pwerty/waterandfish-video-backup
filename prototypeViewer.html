<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prototype Viewer - ëœë“œë§ˆí¬ vs ì›¹ìº  ë¹„êµ</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            height: 100vh;
            overflow: hidden;
        }
        .header {
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            padding: 15px 30px;
            color: #333;
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
        }
        .header-content {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 30px;
        }
        .header-title {
            flex-shrink: 0;
        }
        .header-title h1 {
            font-size: 24px;
            font-weight: 300;
            margin-bottom: 5px;
            color: #2c3e50;
        }
        .header-title p {
            font-size: 14px;
            opacity: 0.7;
            color: #34495e;
            margin: 0;
        }
        .header-controls {
            display: flex;
            align-items: center;
            gap: 20px;
            flex-wrap: wrap;
        }
        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .control-group label {
            color: #2c3e50;
            font-size: 12px;
            font-weight: 500;
            white-space: nowrap;
        }
        .control-buttons {
            display: flex;
            gap: 5px;
        }
        .control-buttons button {
            padding: 6px 12px;
            font-size: 11px;
        }
        .control-toggles {
            display: flex;
            gap: 15px;
        }
        .control-toggles label {
            color: #2c3e50;
            font-size: 12px;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .main-container {
            display: flex;
            height: calc(100vh - 80px);
        }
        .left-panel, .right-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            position: relative;
        }
        .left-panel {
            background: rgba(255, 255, 255, 0.95);
            border-right: 2px solid rgba(0, 0, 0, 0.1);
        }
        .right-panel {
            background: rgba(255, 255, 255, 0.95);
        }
        .panel-title {
            background: rgba(52, 73, 94, 0.9);
            color: white;
            padding: 10px 20px;
            font-size: 16px;
            font-weight: 500;
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
        }
        .controls {
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
        }
        .control-row {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 10px;
        }
        .control-row:last-child { margin-bottom: 0; }
        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .control-group label {
            color: #2c3e50;
            font-size: 12px;
            min-width: 60px;
            font-weight: 500;
        }
        select, input[type="range"] {
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid rgba(0, 0, 0, 0.2);
            color: #2c3e50;
            padding: 5px 8px;
            border-radius: 4px;
            font-size: 12px;
        }
        select option {
            background: #fff;
            color: #2c3e50;
        }
        button {
            background: linear-gradient(45deg, #3498db, #2980b9);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s ease;
        }
        button:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.3);
        }
        button:active {
            transform: translateY(0);
        }
        .canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            background: #f8f9fa;
        }
        #landmark-canvas, #webcam-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        .webcam-container {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #f8f9fa;
            position: relative;
        }
        #webcam-video {
            max-width: 100%;
            max-height: 100%;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }
        #webcam-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            border-radius: 8px;
        }
        .webcam-overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.9);
            color: #2c3e50;
            padding: 10px 15px;
            border-radius: 6px;
            font-size: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        .status-indicator {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #e74c3c;
        }
        .status-indicator.active {
            background: #27ae60;
            box-shadow: 0 0 10px #27ae60;
        }
        .info-text {
            color: #7f8c8d;
            font-size: 11px;
            margin-top: 5px;
        }
        .legend {
            display: flex;
            gap: 15px;
            margin-top: 10px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
            color: #2c3e50;
            font-size: 11px;
        }
        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="header-content">
            <div class="header-title">
                <h1>Prototype Viewer</h1>
                <p>ëœë“œë§ˆí¬ ì• ë‹ˆë©”ì´ì…˜ vs ì‹¤ì‹œê°„ ì›¹ìº  ë¹„êµ</p>
            </div>
            <div class="header-controls">
                <div class="control-group">
                    <label>ë¹„ë””ì˜¤:</label>
                    <select id="video-select"></select>
                </div>
                <div class="control-group">
                    <label>í”„ë ˆì„:</label>
                    <span id="current-frame">0</span>
                </div>
                <div class="control-buttons">
                    <button onclick="previousFrame()">â—€</button>
                    <button onclick="playAnimation()" id="play-btn">â–¶</button>
                    <button onclick="nextFrame()">â–¶</button>
                    <button onclick="resetCamera()">ğŸ”„</button>
                </div>
                <div class="control-group">
                    <label>í”„ë ˆì„:</label>
                    <input type="range" id="frame-slider" min="0" max="0" value="0" style="width: 120px;" oninput="sliderFrame(this.value)">
                </div>
                <div class="control-group">
                    <label>ì†ë„:</label>
                    <input type="range" id="speed" min="1" max="30" value="5" onchange="updateSpeed()" style="width: 80px;">
                    <span id="speed-value">5</span>
                </div>
                <div class="control-toggles">
                    <label><input type="checkbox" id="show-cylinders" checked> ì›ê¸°ë‘¥(ì„ )</label>
                    <label><input type="checkbox" id="show-left-hand" checked> ì¢Œì¸¡ ì†</label>
                    <label><input type="checkbox" id="show-right-hand" checked> ìš°ì¸¡ ì†</label>
                </div>
            </div>
        </div>
    </div>
    
    <div class="main-container">
        <!-- ì¢Œì¸¡ íŒ¨ë„: ëœë“œë§ˆí¬ ë·°ì–´ (ì „ì²´ ê³µê°„) -->
        <div class="left-panel">
            <div class="panel-title">3D ëœë“œë§ˆí¬ ë·°ì–´</div>
            <div class="canvas-container">
                <canvas id="landmark-canvas"></canvas>
            </div>
        </div>
        
        <!-- ìš°ì¸¡ íŒ¨ë„: ì›¹ìº  + ì»¨íŠ¸ë¡¤ -->
        <div class="right-panel">
            <div class="panel-title">ì‹¤ì‹œê°„ ì›¹ìº </div>
            
            <div class="webcam-container">
                <video id="webcam-video" autoplay muted playsinline></video>
                <canvas id="webcam-overlay" style="position: absolute; top: 0; left: 0; pointer-events: none;"></canvas>
                <div class="webcam-overlay">
                    <div>ì›¹ìº  ìŠ¤íŠ¸ë¦¼</div>
                    <div id="webcam-status">ì—°ê²° ì¤‘...</div>
                </div>
                <div class="status-indicator" id="webcam-indicator"></div>
            </div>
        </div>
    </div>

    <script>
        // ëœë“œë§ˆí¬ ë·°ì–´ ê´€ë ¨ ë³€ìˆ˜ë“¤
        let scene, camera, renderer;
        let poseObjects = [], leftHandObjects = [], rightHandObjects = [];
        let poseLines = [], leftHandLines = [], rightHandLines = [];
        let currentFrame = 0;
        let isPlaying = false;
        let animationSpeed = 5;
        let animationInterval;
        let allData = null;
        let data = null;
        
        // ì¹´ë©”ë¼ ì»¨íŠ¸ë¡¤ ë³€ìˆ˜ (í”Œë¼ì´/í”„ë¦¬ ë¬´ë¸Œ)
        // ì´ˆê¸° ì¹´ë©”ë¼ ì„¤ì •:
        // - ìœ„ì¹˜: (-0.388, 0.334, -0.655) - ì‚¬ìš©ì ì§€ì • ìœ„ì¹˜
        // - Yaw: -10.3ë„ (ì¢Œìš° íšŒì „) - ì‚¬ìš©ì ì§€ì • ê°ë„
        // - Pitch: 178.7ë„ (ìƒí•˜ íšŒì „) - ì‚¬ìš©ì ì§€ì • ê°ë„
        // - Roll: 0ë„ (ì‹œì  íšŒì „) - ì‚¬ìš©ì ì§€ì • ê°ë„
        let cameraInitPos = { x: -0.388, y: 0.334, z: -0.655 };
        let cameraInitRot = { x: 0, y: 0, z: 0 };
        let isMouseDown = false;
        let lastMouseX = 0, lastMouseY = 0;
        let yaw = 0;
        let pitch = 0;
        let roll = 0;
        
        // ìƒ‰ìƒ
        const POSE_COLOR = 0x00b894;
        const LEFT_COLOR = 0x0984e3;
        const RIGHT_COLOR = 0xd63031;
        
        // ì—°ê²° êµ¬ì¡°
        const POSE_CONNECTIONS = [
            [0,1],[1,2],[2,3],[3,7],[0,4],[4,5],[5,6],[6,8],[9,10],[11,12],[11,13],[13,15],[15,17],[15,19],[15,21],[17,19],[12,14],[14,16],[16,18],[16,20],[16,22],[18,20],[11,23],[12,24],[23,24],[23,25],[24,26],[25,27],[26,28],[27,29],[28,30],[29,31],[30,32],[27,31],[28,32]
        ];
        const HAND_CONNECTIONS = [
            [0,1],[1,2],[2,3],[3,4],
            [0,5],[5,6],[6,7],[7,8],
            [0,9],[9,10],[10,11],[11,12],
            [0,13],[13,14],[14,15],[15,16],
            [0,17],[17,18],[18,19],[19,20],
            [5,9],[9,13],[13,17],[5,17]
        ];
        
        // ì›¹ìº  ê´€ë ¨ ë³€ìˆ˜
        let webcamStream = null;
        let webcamVideo = null;
        
        // ì´ˆê¸°í™”
        window.onload = function() {
            initLandmarkViewer();
            initWebcam();
        };
        
        // ëœë“œë§ˆí¬ ë·°ì–´ ì´ˆê¸°í™”
        function initLandmarkViewer() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf8f9fa);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / 2 / window.innerHeight, 0.001, 1000);
            camera.position.set(cameraInitPos.x, cameraInitPos.y, cameraInitPos.z);
            camera.rotation.set(cameraInitRot.x, cameraInitRot.y, cameraInitRot.z);
            yaw = -10.3 * Math.PI / 180;
            pitch = 178.7 * Math.PI / 180;
            roll = 0 * Math.PI / 180;
            updateCameraDirection();
            
            const canvas = document.getElementById('landmark-canvas');
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true, alpha: true });
            renderer.setSize(canvas.offsetWidth, canvas.offsetHeight);
            renderer.setClearColor(0xf8f9fa, 1);
            
            const ambientLight = new THREE.AmbientLight(0x404040, 0.8);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);
            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight2.position.set(-1, 1, -1);
            scene.add(directionalLight2);
            
            // ë°ì´í„° ë¡œë“œ
            loadLandmarkData();
            
            // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
            setupEventListeners();
            
            animate();
            
            // ì´ˆê¸° ì¹´ë©”ë¼ ìƒíƒœ ë¡œê·¸
            logCameraState('ì´ˆê¸°í™”');
        }
        
        // ì›¹ìº  ì´ˆê¸°í™”
        async function initWebcam() {
            try {
                console.log('ì›¹ìº  ì´ˆê¸°í™” ì‹œì‘...');
                webcamVideo = document.getElementById('webcam-video');
                webcamStream = await navigator.mediaDevices.getUserMedia({ 
                    video: { 
                        width: { ideal: 640 },
                        height: { ideal: 480 }
                    }, 
                    audio: false 
                });
                webcamVideo.srcObject = webcamStream;
                
                // ë¹„ë””ì˜¤ ë¡œë“œ ì™„ë£Œ ëŒ€ê¸°
                await new Promise((resolve) => {
                    webcamVideo.onloadedmetadata = () => {
                        console.log('ì›¹ìº  ë¹„ë””ì˜¤ ë¡œë“œ ì™„ë£Œ:', webcamVideo.videoWidth, 'x', webcamVideo.videoHeight);
                        resolve();
                    };
                });
                
                webcamVideo.play();
                console.log('ì›¹ìº  ì¬ìƒ ì‹œì‘');
                
                document.getElementById('webcam-status').textContent = 'ì—°ê²°ë¨';
                document.getElementById('webcam-indicator').classList.add('active');
                
                // MediaPipe Tasks Vision ì´ˆê¸°í™”
                await initMediaPipeHands();
            } catch (error) {
                console.error('ì›¹ìº  ì ‘ê·¼ ì‹¤íŒ¨:', error);
                document.getElementById('webcam-status').textContent = 'ì ‘ê·¼ ì‹¤íŒ¨';
                document.getElementById('webcam-video').style.display = 'none';
            }
        }
        
        // MediaPipe Tasks Vision ì´ˆê¸°í™”
        let handLandmarker = null;
        let webcamOverlay = null;
        let webcamCtx = null;
        
        async function initMediaPipeHands() {
            try {
                console.log('MediaPipe Tasks Vision ëª¨ë“ˆ ë¡œë“œ ì‹œì‘...');
                // MediaPipe Tasks Vision ëª¨ë“ˆ ë¡œë“œ
                const { HandLandmarker, FilesetResolver } = await import("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0");
                console.log('MediaPipe ëª¨ë“ˆ ë¡œë“œ ì™„ë£Œ');
                
                console.log('FilesetResolver ì´ˆê¸°í™”...');
                const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm");
                console.log('FilesetResolver ì´ˆê¸°í™” ì™„ë£Œ');
                
                console.log('HandLandmarker ìƒì„± ì‹œì‘...');
                handLandmarker = await HandLandmarker.createFromOptions(vision, {
                    baseOptions: {
                        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                        delegate: "GPU"
                    },
                    runningMode: "VIDEO",
                    numHands: 2
                });
                console.log('HandLandmarker ìƒì„± ì™„ë£Œ');
                
                // ì›¹ìº  ì˜¤ë²„ë ˆì´ ìº”ë²„ìŠ¤ ì„¤ì •
                webcamOverlay = document.getElementById('webcam-overlay');
                webcamCtx = webcamOverlay.getContext('2d');
                console.log('ì›¹ìº  ì˜¤ë²„ë ˆì´ ìº”ë²„ìŠ¤ ì„¤ì • ì™„ë£Œ');
                
                // ë¹„ë””ì˜¤ í¬ê¸° ì„¤ì •
                console.log('ë¹„ë””ì˜¤ í¬ê¸° ì„¤ì •:', webcamVideo.videoWidth, 'x', webcamVideo.videoHeight);
                webcamOverlay.width = webcamVideo.videoWidth;
                webcamOverlay.height = webcamVideo.videoHeight;
                
                document.getElementById('webcam-status').textContent = 'ì† ê°ì§€ í™œì„±í™”';
                console.log('MediaPipe Hands ì´ˆê¸°í™” ì™„ë£Œ');
                
                // ì¦‰ì‹œ ì† ê°ì§€ ì‹œì‘
                console.log('ì† ê°ì§€ ì¦‰ì‹œ ì‹œì‘...');
                setTimeout(() => {
                    startHandDetection();
                }, 100);
                
            } catch (error) {
                console.error('MediaPipe Hands ì´ˆê¸°í™” ì‹¤íŒ¨:', error);
                document.getElementById('webcam-status').textContent = 'ì† ê°ì§€ ì´ˆê¸°í™” ì‹¤íŒ¨';
            }
        }
        
        function startHandDetection() {
            console.log('=== ì† ê°ì§€ ì‹œì‘ í•¨ìˆ˜ í˜¸ì¶œ ===');
            console.log('handLandmarker ì¡´ì¬:', !!handLandmarker);
            console.log('webcamVideo ì¡´ì¬:', !!webcamVideo);
            console.log('webcamVideo readyState:', webcamVideo ? webcamVideo.readyState : 'N/A');
            console.log('webcamVideo videoWidth:', webcamVideo ? webcamVideo.videoWidth : 'N/A');
            console.log('webcamVideo videoHeight:', webcamVideo ? webcamVideo.videoHeight : 'N/A');
            console.log('webcamOverlay ì¡´ì¬:', !!webcamOverlay);
            console.log('webcamCtx ì¡´ì¬:', !!webcamCtx);
            
            // ì¡°ê±´ í™•ì¸
            const hasHandLandmarker = !!handLandmarker;
            const hasVideo = !!webcamVideo;
            const videoReady = hasVideo && webcamVideo.readyState >= 2;
            const hasOverlay = !!webcamOverlay && !!webcamCtx;
            
            console.log('ì¡°ê±´ í™•ì¸:', {
                hasHandLandmarker,
                hasVideo,
                videoReady,
                hasOverlay
            });
            
            if (hasHandLandmarker && hasVideo && hasOverlay) {
                console.log('ëª¨ë“  ì¡°ê±´ ì¶©ì¡±! ì† ê°ì§€ ë£¨í”„ ì‹œì‘');
                detectHands();
            } else {
                console.log('ì¡°ê±´ ë¶ˆì¶©ì¡±, 1ì´ˆ í›„ ì¬ì‹œë„...');
                // ì¡°ê±´ì´ ì¶©ì¡±ë˜ì§€ ì•Šìœ¼ë©´ 1ì´ˆ í›„ ë‹¤ì‹œ ì‹œë„
                setTimeout(startHandDetection, 1000);
            }
        }
        
        async function detectHands() {
            try {
                console.log('ì† ê°ì§€ ì‹¤í–‰ ì¤‘... (í”„ë ˆì„:', Date.now(), ')');
                
                // ë¹„ë””ì˜¤ê°€ ì¤€ë¹„ë˜ì§€ ì•Šì•˜ìœ¼ë©´ ëŒ€ê¸°
                if (webcamVideo.readyState < 2) {
                    console.log('ë¹„ë””ì˜¤ê°€ ì•„ì§ ì¤€ë¹„ë˜ì§€ ì•ŠìŒ, ë‹¤ìŒ í”„ë ˆì„ì—ì„œ ì¬ì‹œë„');
                    requestAnimationFrame(detectHands);
                    return;
                }
                
                const results = await handLandmarker.detectForVideo(webcamVideo, performance.now());
                console.log('ì† ê°ì§€ ê²°ê³¼:', results);
                
                // ì˜¤ë²„ë ˆì´ ìº”ë²„ìŠ¤ í´ë¦¬ì–´
                webcamCtx.clearRect(0, 0, webcamOverlay.width, webcamOverlay.height);
                
                // ì† ëœë“œë§ˆí¬ ê·¸ë¦¬ê¸°
                if (results && results.landmarks && results.landmarks.length > 0) {
                    console.log('ê°ì§€ëœ ì† ê°œìˆ˜:', results.landmarks.length);
                    console.log('ì† êµ¬ë¶„ ì •ë³´:', results.handedness);
                    
                    results.landmarks.forEach((landmarks, handIndex) => {
                        // handedness ì •ë³´ë¥¼ ì‚¬ìš©í•˜ì—¬ ì‹¤ì œ ì™¼ì†/ì˜¤ë¥¸ì† êµ¬ë¶„
                        const handedness = results.handedness && results.handedness[handIndex] ? results.handedness[handIndex][0] : null;
                        let color, handType;
                        
                        if (handedness) {
                            if (handedness.categoryName === 'Left') {
                                color = '#00FF00'; // ì™¼ì†: ì´ˆë¡ìƒ‰
                                handType = 'ì™¼ì†';
                            } else if (handedness.categoryName === 'Right') {
                                color = '#FF0000'; // ì˜¤ë¥¸ì†: ë¹¨ê°„ìƒ‰
                                handType = 'ì˜¤ë¥¸ì†';
                            } else {
                                color = '#FFFF00'; // ì•Œ ìˆ˜ ì—†ìŒ: ë…¸ë€ìƒ‰
                                handType = 'ì•Œ ìˆ˜ ì—†ìŒ';
                            }
                        } else {
                            // handedness ì •ë³´ê°€ ì—†ìœ¼ë©´ ê¸°ì¡´ ë°©ì‹ ì‚¬ìš©
                            color = handIndex === 0 ? '#00FF00' : '#FF0000';
                            handType = handIndex === 0 ? 'ì²« ë²ˆì§¸ ì†' : 'ë‘ ë²ˆì§¸ ì†';
                        }
                        
                        console.log(`ì† ${handIndex + 1}: ${handType} (${color})`);
                        drawHandLandmarks(landmarks, color);
                    });
                } else {
                    console.log('ê°ì§€ëœ ì†ì´ ì—†ìŠµë‹ˆë‹¤');
                }
                
                // ë‹¤ìŒ í”„ë ˆì„ ì²˜ë¦¬
                requestAnimationFrame(detectHands);
            } catch (error) {
                console.error('ì† ê°ì§€ ì˜¤ë¥˜:', error);
                // ì˜¤ë¥˜ ë°œìƒ ì‹œì—ë„ ê³„ì† ì‹œë„
                setTimeout(() => {
                    requestAnimationFrame(detectHands);
                }, 100);
            }
        }
        
        function drawHandLandmarks(landmarks, color) {
            // ì† ì—°ê²°ì„  ì •ì˜
            const HAND_CONNECTIONS = [
                [0,1],[1,2],[2,3],[3,4],
                [0,5],[5,6],[6,7],[7,8],
                [0,9],[9,10],[10,11],[11,12],
                [0,13],[13,14],[14,15],[15,16],
                [0,17],[17,18],[18,19],[19,20],
                [5,9],[9,13],[13,17],[5,17]
            ];
            
            // ì—°ê²°ì„  ê·¸ë¦¬ê¸°
            HAND_CONNECTIONS.forEach(([start, end]) => {
                const startPoint = landmarks[start];
                const endPoint = landmarks[end];
                
                if (startPoint && endPoint) {
                    const startX = startPoint.x * webcamOverlay.width;
                    const startY = startPoint.y * webcamOverlay.height;
                    const endX = endPoint.x * webcamOverlay.width;
                    const endY = endPoint.y * webcamOverlay.height;
                    
                    webcamCtx.strokeStyle = color;
                    webcamCtx.lineWidth = 2;
                    webcamCtx.beginPath();
                    webcamCtx.moveTo(startX, startY);
                    webcamCtx.lineTo(endX, endY);
                    webcamCtx.stroke();
                }
            });
            
            // ëœë“œë§ˆí¬ ì  ê·¸ë¦¬ê¸°
            landmarks.forEach(landmark => {
                const x = landmark.x * webcamOverlay.width;
                const y = landmark.y * webcamOverlay.height;
                
                webcamCtx.fillStyle = color;
                webcamCtx.beginPath();
                webcamCtx.arc(x, y, 3, 0, 2 * Math.PI);
                webcamCtx.fill();
            });
        }
        
        // ëœë“œë§ˆí¬ ë°ì´í„° ë¡œë“œ
        function loadLandmarkData() {
            // file_list.jsonì—ì„œ íŒŒì¼ ëª©ë¡ ë¡œë“œ
            fetch('result/file_list.json')
                .then(response => {
                    if (!response.ok) {
                        throw new Error('file_list.json ë¡œë“œ ì‹¤íŒ¨');
                    }
                    return response.json();
                })
                .then(fileList => {
                    const jsonFiles = fileList.landmark_files || [];
                    console.log('íŒŒì¼ ëª©ë¡ì—ì„œ ë°œê²¬ëœ íŒŒì¼ë“¤:', jsonFiles);
                    
                    if (jsonFiles.length === 0) {
                        throw new Error('file_list.jsonì— íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤.');
                    }
                    
                    // ê° íŒŒì¼ì„ ë¡œë“œ
                    const loadPromises = jsonFiles.map(filename => 
                        fetch(`result/${filename}`)
                            .then(response => {
                                if (!response.ok) {
                                    throw new Error(`HTTP ${response.status}`);
                                }
                                return response.json();
                            })
                            .then(data => ({ filename, data }))
                            .catch(error => {
                                console.warn(`íŒŒì¼ ë¡œë“œ ì‹¤íŒ¨: ${filename} - ${error.message}`);
                                return null;
                            })
                    );
                    
                    return Promise.all(loadPromises);
                })
                .then(results => {
                    const validResults = results.filter(result => result !== null);
                    
                    if (validResults.length === 0) {
                        throw new Error('ë¡œë“œ ê°€ëŠ¥í•œ JSON íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤.');
                    }
                    
                    console.log('ì„±ê³µì ìœ¼ë¡œ ë¡œë“œëœ íŒŒì¼ë“¤:', validResults.map(r => r.filename));
                    return validResults;
                })
                .then(results => {
                    // allDataë¥¼ íŒŒì¼ëª…ì„ í‚¤ë¡œ í•˜ëŠ” ê°ì²´ë¡œ êµ¬ì„±
                    allData = {};
                    results.forEach(({ filename, data }) => {
                        const baseName = filename.replace('_landmarks.json', '');
                        allData[baseName] = data;
                    });
                    
                    const select = document.getElementById('video-select');
                    
                    // íŒŒì¼ ì„ íƒ ì˜µì…˜ ìƒì„±
                    Object.keys(allData).forEach(filename => {
                        const opt = document.createElement('option');
                        opt.value = filename;
                        opt.textContent = filename;
                        select.appendChild(opt);
                    });
                    
                    select.onchange = function() {
                        data = allData[select.value];
                        document.getElementById('frame-slider').max = data.pose.length - 1;
                        loadFrame(0);
                    };
                    
                    select.value = Object.keys(allData)[0];
                    select.onchange();
                })
                .catch(error => {
                    console.error('ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨:', error);
                    document.querySelector('.left-panel').innerHTML = `
                        <div style="color: white; padding: 20px; text-align: center;">
                            <h3>ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨</h3>
                            <p>${error.message}</p>
                            <p>result ë””ë ‰í† ë¦¬ì— JSON íŒŒì¼ì´ ìˆëŠ”ì§€ í™•ì¸í•´ì£¼ì„¸ìš”.</p>
                        </div>
                    `;
                });
        }
        
        // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì„¤ì •
        function setupEventListeners() {
            // í‚¤ë³´ë“œ ì»¨íŠ¸ë¡¤ (ì‹œì  ì´ë™ ë¹„í™œì„±í™”)
            // document.addEventListener('keydown', handleKeyDown);
            
            // ë§ˆìš°ìŠ¤ ì»¨íŠ¸ë¡¤ (ì‹œì  ì´ë™ ë¹„í™œì„±í™”)
            // const canvas = document.getElementById('landmark-canvas');
            // canvas.addEventListener('mousedown', handleMouseDown);
            // canvas.addEventListener('mousemove', handleMouseMove);
            // canvas.addEventListener('mouseup', handleMouseUp);
            // canvas.addEventListener('mouseleave', handleMouseUp);
            // canvas.addEventListener('wheel', handleWheel);
            
            // ì²´í¬ë°•ìŠ¤ ì´ë²¤íŠ¸ (êµ¬ ì˜µì…˜ê³¼ ëª¸ ì˜µì…˜ ì œê±°)
            document.getElementById('show-cylinders').addEventListener('change', () => loadFrame(currentFrame));
            document.getElementById('show-left-hand').addEventListener('change', () => loadFrame(currentFrame));
            document.getElementById('show-right-hand').addEventListener('change', () => loadFrame(currentFrame));
        }
        
        // ì• ë‹ˆë©”ì´ì…˜ ë£¨í”„
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        
        // ì¹´ë©”ë¼ ë°©í–¥ ì—…ë°ì´íŠ¸
        function updateCameraDirection() {
            camera.rotation.order = 'YXZ';
            camera.rotation.y = yaw;
            camera.rotation.x = pitch;
            camera.rotation.z = roll;
        }
        
        // ì¹´ë©”ë¼ ìƒíƒœ ë¡œê·¸ ì¶œë ¥
        function logCameraState(action) {
            const yawDegrees = (yaw * 180 / Math.PI).toFixed(1);
            const pitchDegrees = (pitch * 180 / Math.PI).toFixed(1);
            const rollDegrees = (roll * 180 / Math.PI).toFixed(1);
            console.log(`[${action}] ì¹´ë©”ë¼ ìƒíƒœ:`, {
                ìœ„ì¹˜: {
                    x: camera.position.x.toFixed(3),
                    y: camera.position.y.toFixed(3),
                    z: camera.position.z.toFixed(3)
                },
                ê°ë„: {
                    yaw: yawDegrees + 'Â°',
                    pitch: pitchDegrees + 'Â°',
                    roll: rollDegrees + 'Â°'
                }
            });
        }
        
        // í‚¤ë³´ë“œ ì´ë²¤íŠ¸ ì²˜ë¦¬
        function handleKeyDown(e) {
            const moveSpeed = 0.1;
            const rotateSpeed = 0.1;
            let forward = new THREE.Vector3();
            let right = new THREE.Vector3();
            let up = new THREE.Vector3(0, 1, 0);
            camera.getWorldDirection(forward);
            right.crossVectors(forward, up).normalize();
            
            let moved = false;
            switch(e.key.toLowerCase()) {
                case 'w':
                    camera.position.add(forward.clone().multiplyScalar(moveSpeed));
                    moved = true;
                    break;
                case 's':
                    camera.position.add(forward.clone().multiplyScalar(-moveSpeed));
                    moved = true;
                    break;
                case 'a':
                    camera.position.add(right.clone().multiplyScalar(-moveSpeed));
                    moved = true;
                    break;
                case 'd':
                    camera.position.add(right.clone().multiplyScalar(moveSpeed));
                    moved = true;
                    break;
                case 'q':
                    camera.position.y += moveSpeed;
                    moved = true;
                    break;
                case 'e':
                    camera.position.y -= moveSpeed;
                    moved = true;
                    break;
                case 'z':
                    roll -= rotateSpeed;
                    updateCameraDirection();
                    moved = true;
                    break;
                case 'c':
                    roll += rotateSpeed;
                    updateCameraDirection();
                    moved = true;
                    break;
                case 'r':
                    resetCamera();
                    return; // resetCameraì—ì„œ ë¡œê·¸ ì¶œë ¥
            }
            
            if (moved) {
                logCameraState('í‚¤ë³´ë“œ ì´ë™');
            }
        }
        
        // ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸ ì²˜ë¦¬
        function handleMouseDown(e) {
            isMouseDown = true;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
        }
        
        function handleMouseMove(e) {
            if (!isMouseDown) return;
            const deltaX = e.clientX - lastMouseX;
            const deltaY = e.clientY - lastMouseY;
            const rotateSpeed = 0.005;
            yaw -= deltaX * rotateSpeed;
            pitch -= deltaY * rotateSpeed;
            updateCameraDirection();
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
            
            logCameraState('ë§ˆìš°ìŠ¤ íšŒì „');
        }
        
        function handleMouseUp() {
            isMouseDown = false;
        }
        
        function handleWheel(e) {
            e.preventDefault();
            const moveSpeed = 0.2;
            let forward = new THREE.Vector3();
            camera.getWorldDirection(forward);
            camera.position.add(forward.clone().multiplyScalar(-e.deltaY * moveSpeed * 0.01));
            
            logCameraState('íœ  ì¤Œ');
        }
        
        // í”„ë ˆì„ ë¡œë“œ
        function loadFrame(frameIndex) {
            if (!data) return;
            currentFrame = frameIndex;
            clearScene();
            
            const showSpheres = false; // êµ¬ ì˜µì…˜ ë¹„í™œì„±í™”
            const showCylinders = document.getElementById('show-cylinders').checked;
            const showPose = false; // ëª¸ ì˜µì…˜ ë¹„í™œì„±í™”
            const showLeftHand = document.getElementById('show-left-hand').checked;
            const showRightHand = document.getElementById('show-right-hand').checked;
            
            // ëœë“œë§ˆí¬ íšŒì „ í•¨ìˆ˜ (Yì¶• ì¤‘ì‹¬ ì‹œê³„ë°©í–¥ 180ë„)
            function rotateLandmark(lm) {
                return [-lm[0], lm[1], -lm[2]]; // xì™€ z ì¢Œí‘œ ë°˜ì „
            }
            
            // Pose
            if (data.pose && data.pose[frameIndex] && showPose) {
                const rotatedPose = data.pose[frameIndex].map(rotateLandmark);
                if (showSpheres) {
                    rotatedPose.forEach(lm => {
                        // ë©”ì¸ êµ¬
                        const geometry = new THREE.SphereGeometry(0.012, 12, 12);
                        const material = new THREE.MeshLambertMaterial({ 
                            color: POSE_COLOR,
                            emissive: POSE_COLOR,
                            emissiveIntensity: 0.1
                        });
                        const sphere = new THREE.Mesh(geometry, material);
                        sphere.position.set(lm[0], lm[1], lm[2]);
                        scene.add(sphere);
                        poseObjects.push(sphere);
                        
                        // ì™¸ê³½ì„  êµ¬
                        const outlineGeometry = new THREE.SphereGeometry(0.016, 12, 12);
                        const outlineMaterial = new THREE.MeshBasicMaterial({ 
                            color: 0x000000, 
                            transparent: true, 
                            opacity: 0.6,
                            side: THREE.BackSide
                        });
                        const outlineSphere = new THREE.Mesh(outlineGeometry, outlineMaterial);
                        outlineSphere.position.set(lm[0], lm[1], lm[2]);
                        scene.add(outlineSphere);
                        poseObjects.push(outlineSphere);
                    });
                }
                if (showCylinders) {
                    drawConnectionsCylinder(rotatedPose, POSE_CONNECTIONS, POSE_COLOR, poseLines);
                }
            }
            
            // Left Hand
            if (data.left_hand && data.left_hand[frameIndex] && showLeftHand) {
                const rotatedLeftHand = data.left_hand[frameIndex].map(rotateLandmark);
                if (showSpheres) {
                    rotatedLeftHand.forEach(lm => {
                        // ë©”ì¸ êµ¬
                        const geometry = new THREE.SphereGeometry(0.014, 12, 12);
                        const material = new THREE.MeshLambertMaterial({ 
                            color: LEFT_COLOR,
                            emissive: LEFT_COLOR,
                            emissiveIntensity: 0.1
                        });
                        const sphere = new THREE.Mesh(geometry, material);
                        sphere.position.set(lm[0], lm[1], lm[2]);
                        scene.add(sphere);
                        leftHandObjects.push(sphere);
                        
                        // ì™¸ê³½ì„  êµ¬
                        const outlineGeometry = new THREE.SphereGeometry(0.018, 12, 12);
                        const outlineMaterial = new THREE.MeshBasicMaterial({ 
                            color: 0x000000, 
                            transparent: true, 
                            opacity: 0.6,
                            side: THREE.BackSide
                        });
                        const outlineSphere = new THREE.Mesh(outlineGeometry, outlineMaterial);
                        outlineSphere.position.set(lm[0], lm[1], lm[2]);
                        scene.add(outlineSphere);
                        leftHandObjects.push(outlineSphere);
                    });
                }
                if (showCylinders) {
                    drawConnectionsCylinder(rotatedLeftHand, HAND_CONNECTIONS, LEFT_COLOR, leftHandLines);
                }
            }
            
            // Right Hand
            if (data.right_hand && data.right_hand[frameIndex] && showRightHand) {
                const rotatedRightHand = data.right_hand[frameIndex].map(rotateLandmark);
                if (showSpheres) {
                    rotatedRightHand.forEach(lm => {
                        // ë©”ì¸ êµ¬
                        const geometry = new THREE.SphereGeometry(0.014, 12, 12);
                        const material = new THREE.MeshLambertMaterial({ 
                            color: RIGHT_COLOR,
                            emissive: RIGHT_COLOR,
                            emissiveIntensity: 0.1
                        });
                        const sphere = new THREE.Mesh(geometry, material);
                        sphere.position.set(lm[0], lm[1], lm[2]);
                        scene.add(sphere);
                        rightHandObjects.push(sphere);
                        
                        // ì™¸ê³½ì„  êµ¬
                        const outlineGeometry = new THREE.SphereGeometry(0.018, 12, 12);
                        const outlineMaterial = new THREE.MeshBasicMaterial({ 
                            color: 0x000000, 
                            transparent: true, 
                            opacity: 0.6,
                            side: THREE.BackSide
                        });
                        const outlineSphere = new THREE.Mesh(outlineGeometry, outlineMaterial);
                        outlineSphere.position.set(lm[0], lm[1], lm[2]);
                        scene.add(outlineSphere);
                        rightHandObjects.push(outlineSphere);
                    });
                }
                if (showCylinders) {
                    drawConnectionsCylinder(rotatedRightHand, HAND_CONNECTIONS, RIGHT_COLOR, rightHandLines);
                }
            }
            
            document.getElementById('current-frame').textContent = currentFrame;
            document.getElementById('frame-slider').value = currentFrame;
        }
        
        // ì”¬ í´ë¦¬ì–´
        function clearScene() {
            [...poseObjects, ...leftHandObjects, ...rightHandObjects].forEach(obj => {
                scene.remove(obj);
                if (obj.geometry) obj.geometry.dispose();
                if (obj.material) obj.material.dispose();
            });
            [...poseLines, ...leftHandLines, ...rightHandLines].forEach(line => {
                scene.remove(line);
                if (line.geometry) line.geometry.dispose();
                if (line.material) line.material.dispose();
            });
            poseObjects = []; leftHandObjects = []; rightHandObjects = [];
            poseLines = []; leftHandLines = []; rightHandLines = [];
        }
        
        // ì—°ê²°ì„  ê·¸ë¦¬ê¸°
        function drawConnectionsCylinder(landmarks, connections, color, lineArray) {
            connections.forEach(connection => {
                if (connection[0] < landmarks.length && connection[1] < landmarks.length) {
                    const start = landmarks[connection[0]];
                    const end = landmarks[connection[1]];
                    const startVec = new THREE.Vector3(start[0], start[1], start[2]);
                    const endVec = new THREE.Vector3(end[0], end[1], end[2]);
                    const distance = startVec.distanceTo(endVec);
                    
                    // ë©”ì¸ ì›ê¸°ë‘¥ (ë” ì§„í•œ ìƒ‰ìƒ)
                    const geometry = new THREE.CylinderGeometry(0.008, 0.008, distance, 12);
                    const material = new THREE.MeshLambertMaterial({ 
                        color: color, 
                        transparent: true, 
                        opacity: 0.9,
                        emissive: color,
                        emissiveIntensity: 0.1
                    });
                    const cylinder = new THREE.Mesh(geometry, material);
                    cylinder.position.copy(startVec).add(endVec).multiplyScalar(0.5);
                    const up = new THREE.Vector3(0, 1, 0);
                    const quaternion = new THREE.Quaternion().setFromUnitVectors(up, new THREE.Vector3().subVectors(endVec, startVec).normalize());
                    cylinder.quaternion.copy(quaternion);
                    scene.add(cylinder);
                    lineArray.push(cylinder);
                    
                    // ì™¸ê³½ì„  ì›ê¸°ë‘¥ (ë” í° ë°˜ì§€ë¦„, ì–´ë‘ìš´ ìƒ‰ìƒ)
                    const outlineGeometry = new THREE.CylinderGeometry(0.012, 0.012, distance, 12);
                    const outlineMaterial = new THREE.MeshBasicMaterial({ 
                        color: 0x000000, 
                        transparent: true, 
                        opacity: 0.6,
                        side: THREE.BackSide
                    });
                    const outlineCylinder = new THREE.Mesh(outlineGeometry, outlineMaterial);
                    outlineCylinder.position.copy(cylinder.position);
                    outlineCylinder.quaternion.copy(cylinder.quaternion);
                    scene.add(outlineCylinder);
                    lineArray.push(outlineCylinder);
                }
            });
        }
        
        // ì»¨íŠ¸ë¡¤ í•¨ìˆ˜ë“¤
        function previousFrame() {
            if (currentFrame > 0) {
                loadFrame(currentFrame - 1);
            }
        }
        
        function nextFrame() {
            if (data && currentFrame < data.pose.length - 1) {
                loadFrame(currentFrame + 1);
            }
        }
        
        function playAnimation() {
            if (isPlaying) {
                isPlaying = false;
                if (animationInterval) {
                    clearInterval(animationInterval);
                    animationInterval = null;
                }
                document.getElementById('play-btn').textContent = 'â–¶ ì¬ìƒ';
            } else {
                isPlaying = true;
                document.getElementById('play-btn').textContent = 'â¸ ì •ì§€';
                animationInterval = setInterval(() => {
                    if (data && currentFrame < data.pose.length - 1) {
                        loadFrame(currentFrame + 1);
                    } else {
                        loadFrame(0);
                    }
                }, 1000 / animationSpeed);
            }
        }
        
        function resetCamera() {
            camera.position.set(cameraInitPos.x, cameraInitPos.y, cameraInitPos.z);
            yaw = -10.3 * Math.PI / 180;
            pitch = 178.7 * Math.PI / 180;
            roll = 0 * Math.PI / 180;
            updateCameraDirection();
            logCameraState('ì¹´ë©”ë¼ ë¦¬ì…‹');
        }
        
        function sliderFrame(val) {
            loadFrame(parseInt(val));
        }
        
        function updateSpeed() {
            animationSpeed = parseInt(document.getElementById('speed').value);
            document.getElementById('speed-value').textContent = animationSpeed;
            if (isPlaying && animationInterval) {
                clearInterval(animationInterval);
                playAnimation();
            }
        }
        
        // ìœˆë„ìš° ë¦¬ì‚¬ì´ì¦ˆ ì²˜ë¦¬
        window.addEventListener('resize', () => {
            const canvas = document.getElementById('landmark-canvas');
            camera.aspect = canvas.offsetWidth / canvas.offsetHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(canvas.offsetWidth, canvas.offsetHeight);
        });
    </script>
</body>
</html> 